name: Deploy to Azure Staging

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual deployment'
        required: false
        default: 'Manual trigger'

env:
  ACR_NAME: ${{ secrets.ACR_NAME }}
  AZURE_WEBAPP_NAME: ${{ secrets.AZURE_WEBAPP_NAME }}
  AZURE_RESOURCE_GROUP: rg-qgp-staging
  ENVIRONMENT_NAME: staging
  IMAGE_NAME: quality-governance-platform
  # Health check configuration - enterprise grade
  HEALTH_CHECK_MAX_ATTEMPTS: 30
  HEALTH_CHECK_INTERVAL: 10

jobs:
  build-and-deploy:
    name: Build and Deploy to Staging
    runs-on: ubuntu-latest
    outputs:
      deployment_id: ${{ steps.generate-id.outputs.deployment_id }}
      image_tag: ${{ steps.build.outputs.image_tag }}
    
    steps:
      - name: Generate deployment ID
        id: generate-id
        run: |
          DEPLOYMENT_ID="staging-$(date +%Y%m%d-%H%M%S)-${{ github.run_number }}"
          echo "deployment_id=$DEPLOYMENT_ID" >> "$GITHUB_OUTPUT"
          echo "üìã Deployment ID: $DEPLOYMENT_ID"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log deployment info
        run: |
          {
            echo "## üöÄ Staging Deployment Started"
            echo ""
            echo "| Item | Value |"
            echo "|------|-------|"
            echo "| **Deployment ID** | ${{ steps.generate-id.outputs.deployment_id }} |"
            echo "| **Trigger** | ${{ github.event_name }} |"
            echo "| **Actor** | ${{ github.actor }} |"
            echo "| **Branch** | ${{ github.ref_name }} |"
            echo "| **Commit** | \`${{ github.sha }}\` |"
            echo "| **Reason** | ${{ github.event.inputs.reason || 'Push to main' }} |"
            echo "| **Timestamp** | $(date -u +"%Y-%m-%dT%H:%M:%SZ") |"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Environment guardrails
        run: |
          if [ -z "$AZURE_RESOURCE_GROUP" ] || [ -z "$AZURE_WEBAPP_NAME" ] || [ -z "$ENVIRONMENT_NAME" ]; then
            echo "‚ùå Guardrail: required env vars missing"
            exit 1
          fi
          rg_lower=$(echo "$AZURE_RESOURCE_GROUP" | tr '[:upper:]' '[:lower:]')
          app_lower=$(echo "$AZURE_WEBAPP_NAME" | tr '[:upper:]' '[:lower:]')
          env_lower=$(echo "$ENVIRONMENT_NAME" | tr '[:upper:]' '[:lower:]')
          if [ "$env_lower" = "production" ]; then
            if echo "$rg_lower$app_lower" | grep -q "staging"; then
              echo "‚ùå Guardrail: production cannot target staging resources"
              exit 1
            fi
          elif [ "$env_lower" = "staging" ]; then
            if echo "$rg_lower$app_lower" | grep -q "prod"; then
              echo "‚ùå Guardrail: staging cannot target production resources"
              exit 1
            fi
          else
            echo "‚ùå Guardrail: unknown environment '$ENVIRONMENT_NAME'"
            exit 1
          fi
          echo "‚úÖ Guardrail: environment targeting validated"

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: az acr login --name "${{ env.ACR_NAME }}"

      - name: Build and push Docker image
        id: build
        run: |
          IMAGE_TAG="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          IMAGE_LATEST="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:latest"
          
          echo "üî® Building image: $IMAGE_TAG"
          docker build -t "$IMAGE_TAG" -t "$IMAGE_LATEST" .
          
          echo "üì§ Pushing images..."
          docker push "$IMAGE_TAG"
          docker push "$IMAGE_LATEST"
          
          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "IMAGE_TAG=$IMAGE_TAG" >> "$GITHUB_ENV"
          
          echo "‚úÖ Image built and pushed successfully"

      - name: Capture expected image digest
        run: |
          EXPECTED_TAG="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          EXPECTED_DIGESTS=$(az acr repository show-manifests \
            --name "${{ env.ACR_NAME }}" \
            --repository "${{ env.IMAGE_NAME }}" \
            --query "[?tags[?@=='${{ github.sha }}']].digest" \
            -o tsv)
          EXPECTED_DIGESTS_CLEAN=$(printf "%s\n" "$EXPECTED_DIGESTS" | sed '/^$/d' | sort -u)
          EXPECTED_DIGEST_COUNT=$(printf "%s\n" "$EXPECTED_DIGESTS_CLEAN" | wc -l | tr -d ' ')
          if [ "$EXPECTED_DIGEST_COUNT" -ne 1 ]; then
            echo "‚ùå Expected exactly 1 digest for tag ${{ github.sha }}, got $EXPECTED_DIGEST_COUNT"
            exit 1
          fi
          EXPECTED_DIGEST=$(printf "%s\n" "$EXPECTED_DIGESTS_CLEAN" | head -n 1 | tr -d '\r')
          if [ -z "$EXPECTED_DIGEST" ]; then
            echo "‚ùå Failed to resolve image digest for ${EXPECTED_TAG}"
            exit 1
          fi
          case "$EXPECTED_DIGEST" in
            sha256:*) ;;
            *)
              echo "‚ùå Unexpected digest format: $EXPECTED_DIGEST"
              exit 1
              ;;
          esac
          
          IMAGE_DIGEST_REF="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}@${EXPECTED_DIGEST}"
          EXPECTED_TAG_SAFE="${{ env.IMAGE_NAME }}:${{ github.sha }}"
          
          {
            echo "EXPECTED_TAG=$EXPECTED_TAG"
            echo "EXPECTED_DIGEST=$EXPECTED_DIGEST"
            echo "IMAGE_DIGEST_REF=$IMAGE_DIGEST_REF"
            echo "EXPECTED_TAG_SAFE=$EXPECTED_TAG_SAFE"
          } >> "$GITHUB_ENV"

      - name: Preflight validation
        run: |
          {
            echo "## ‚úÖ Preflight Validation"
            echo ""
            echo "| Item | Value |"
            echo "|------|-------|"
            echo "| **Environment** | $ENVIRONMENT_NAME |"
            echo "| **Commit** | \`${{ github.sha }}\` |"
            echo "| **Expected Digest** | \`${EXPECTED_DIGEST}\` |"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v3
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          images: ${{ env.IMAGE_DIGEST_REF }}

      - name: Configure App Service environment
        run: |
          echo "üîß Configuring App Service with Key Vault references..."
          
          # Ensure managed identity is enabled
          IDENTITY_ID=$(az webapp identity show \
            --name "${{ env.AZURE_WEBAPP_NAME }}" \
            --resource-group rg-qgp-staging \
            --query principalId -o tsv 2>/dev/null || echo "")
          
          if [ -z "$IDENTITY_ID" ]; then
            echo "   üìå Enabling managed identity..."
            az webapp identity assign \
              --name "${{ env.AZURE_WEBAPP_NAME }}" \
              --resource-group rg-qgp-staging \
              --output none
            
            IDENTITY_ID=$(az webapp identity show \
              --name "${{ env.AZURE_WEBAPP_NAME }}" \
              --resource-group rg-qgp-staging \
              --query principalId -o tsv)
            
            # Wait for identity propagation
            sleep 30
          fi
          echo "   ‚úÖ Managed identity: $IDENTITY_ID"
          
          # Always ensure Key Vault access is configured
          echo "   üîë Ensuring Key Vault access..."
          az keyvault set-policy \
            --name kv-qgp-staging \
            --object-id "$IDENTITY_ID" \
            --secret-permissions get list \
            --output none 2>/dev/null || echo "   ‚ö†Ô∏è Key Vault policy already set or cannot be updated"
          
          # Fetch secrets from Key Vault
          echo "   üîê Fetching secrets from Key Vault..."
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-staging --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-staging --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-staging --name JWT-SECRET-KEY --query value -o tsv)
          
          if [ -z "$DB_URL" ]; then
            echo "   ‚ùå Failed to retrieve DATABASE_URL from Key Vault"
            exit 1
          fi
          echo "   ‚úÖ Secrets retrieved successfully"
          
          # Configure app settings with direct values
          echo "   üìù Setting application configuration..."
          az webapp config appsettings set \
            --name "${{ env.AZURE_WEBAPP_NAME }}" \
            --resource-group rg-qgp-staging \
            --settings \
              APP_ENV="staging" \
              BUILD_SHA="${{ github.sha }}" \
              BUILD_TIME="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              DATABASE_URL="$DB_URL" \
              SECRET_KEY="$SECRET_KEY_VAL" \
              JWT_SECRET_KEY="$JWT_SECRET_VAL" \
              JWT_ALGORITHM="HS256" \
              JWT_ACCESS_TOKEN_EXPIRE_MINUTES="30" \
              JWT_REFRESH_TOKEN_EXPIRE_DAYS="7" \
              LOG_LEVEL="INFO" \
              CORS_ORIGINS='["https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"]' \
              DATABASE_ECHO="false" \
              WEBSITES_PORT="8000" \
              AZURE_CLIENT_ID="${{ secrets.AZURE_AD_CLIENT_ID }}" \
              AZURE_TENANT_ID="${{ secrets.AZURE_AD_TENANT_ID }}" \
              CI_TEST_SECRET="${{ secrets.CI_TEST_SECRET }}" \
            --output none
          
          echo "   ‚úÖ Application settings configured"
          
          # Restart the app to apply new settings
          echo "   üîÑ Restarting application..."
          az webapp restart \
            --name "${{ env.AZURE_WEBAPP_NAME }}" \
            --resource-group rg-qgp-staging
          
          echo "‚úÖ App Service configuration complete"

      - name: Run database migrations
        run: |
          echo "üóÉÔ∏è Running migrations via Azure Container Instance..."
          
          # Fetch secrets into variables
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query "passwords[0].value" -o tsv)
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-staging --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-staging --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-staging --name JWT-SECRET-KEY --query value -o tsv)
          STORAGE_CONN=$(az keyvault secret show --vault-name kv-qgp-staging --name AZURE-STORAGE-CONNECTION-STRING --query value -o tsv)
          
          # Validate secrets
          if [ -z "$DB_URL" ]; then
            echo "‚ùå ERROR: Failed to retrieve DATABASE_URL from Key Vault"
            exit 1
          fi
          if [ -z "$STORAGE_CONN" ]; then
            echo "‚ùå ERROR: Failed to retrieve AZURE_STORAGE_CONNECTION_STRING from Key Vault"
            exit 1
          fi
          echo "‚úÖ Successfully retrieved secrets from Key Vault"
          
          CONTAINER_NAME="qgp-migration-${{ github.run_number }}"
          
          # Create container with secure environment variables
          az container create \
            --name $CONTAINER_NAME \
            --resource-group rg-qgp-staging \
            --location westeurope \
            --os-type Linux \
            --image ${{ env.IMAGE_TAG }} \
            --registry-login-server ${{ env.ACR_NAME }}.azurecr.io \
            --registry-username "$ACR_USERNAME" \
            --registry-password "$ACR_PASSWORD" \
            --restart-policy Never \
            --secure-environment-variables \
              DATABASE_URL="$DB_URL" \
              SECRET_KEY="$SECRET_KEY_VAL" \
              JWT_SECRET_KEY="$JWT_SECRET_VAL" \
              AZURE_STORAGE_CONNECTION_STRING="$STORAGE_CONN" \
            --command-line "alembic upgrade head" \
            --cpu 1 \
            --memory 1
          
          echo "‚è≥ Waiting for migration to complete..."
          
          MAX_WAIT=300
          WAITED=0
          while [ $WAITED -lt $MAX_WAIT ]; do
            STATE=$(az container show --name $CONTAINER_NAME --resource-group rg-qgp-staging --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "Running")
            if [ "$STATE" = "Terminated" ]; then
              echo "‚úÖ Migration container terminated after ${WAITED}s"
              break
            fi
            echo "   Migration still running... (${WAITED}s)"
            sleep 10
            WAITED=$((WAITED + 10))
          done
          
          EXIT_CODE=$(az container show --name $CONTAINER_NAME --resource-group rg-qgp-staging --query "containers[0].instanceView.currentState.exitCode" -o tsv)
          
          echo "üìã Migration exit code: $EXIT_CODE"
          echo "üìã Migration logs:"
          az container logs --name $CONTAINER_NAME --resource-group rg-qgp-staging
          
          if [ "$EXIT_CODE" != "0" ]; then
            echo "‚ùå Migration failed!"
            exit 1
          fi
          
          echo "üßπ Cleaning up migration container..."
          az container delete --name $CONTAINER_NAME --resource-group rg-qgp-staging --yes
          echo "‚úÖ Migrations completed successfully"

      - name: Verify deployment with retry
        id: verify
        run: |
          APP_URL="https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
          MAX_ATTEMPTS=${{ env.HEALTH_CHECK_MAX_ATTEMPTS }}
          INTERVAL=${{ env.HEALTH_CHECK_INTERVAL }}
          
          echo "üîç Verifying deployment endpoint"
          echo "   Max attempts: $MAX_ATTEMPTS"
          echo "   Interval: ${INTERVAL}s"
          echo "   Total timeout: $((MAX_ATTEMPTS * INTERVAL))s"
          echo ""
          
          # Function to check endpoint with retry
          check_endpoint() {
            local endpoint=$1
            local name=$2
            local attempt=1
            
            echo "üì° Checking $name endpoint: $endpoint"
            
            while [ $attempt -le $MAX_ATTEMPTS ]; do
              HTTP_STATUS=$(curl -s -o /tmp/response.txt -w "%{http_code}" --max-time 30 "$endpoint" 2>/dev/null || echo "000")
              
              if [ "$HTTP_STATUS" = "200" ]; then
                echo "   ‚úÖ Attempt $attempt: $name check PASSED (HTTP $HTTP_STATUS)"
                return 0
              elif [ "$HTTP_STATUS" = "000" ]; then
                echo "   ‚è≥ Attempt $attempt/$MAX_ATTEMPTS: Connection failed, retrying in ${INTERVAL}s..."
              else
                echo "   ‚è≥ Attempt $attempt/$MAX_ATTEMPTS: HTTP $HTTP_STATUS, retrying in ${INTERVAL}s..."
                # After 10 failed attempts, try to capture app logs for diagnostics
                if [ $attempt -eq 10 ]; then
                  echo "   üìã Capturing diagnostic logs..."
                  az webapp log download \
                    --name "${{ env.AZURE_WEBAPP_NAME }}" \
                    --resource-group rg-qgp-staging \
                    --log-file /tmp/app_logs.zip 2>/dev/null || true
                fi
              fi
              
              attempt=$((attempt + 1))
              sleep $INTERVAL
            done
            
            echo "   ‚ùå $name check FAILED after $MAX_ATTEMPTS attempts"
            return 1
          }
          
          # Initial wait for app to start (longer wait after Key Vault config)
          echo "‚è≥ Initial wait (60s) for app cold start and Key Vault reference resolution..."
          sleep 60
          
          # Health check with retry
          if ! check_endpoint "$APP_URL/healthz" "Health"; then
            echo ""
            echo "‚ùå DEPLOYMENT VERIFICATION FAILED"
            echo "   Health endpoint did not respond with 200 after $MAX_ATTEMPTS attempts"
            echo ""
            echo "üìã Last response body:"
            cat /tmp/response.txt 2>/dev/null || echo "(empty)"
            echo ""
            echo "üìã Checking App Service status..."
            az webapp show \
              --name "${{ env.AZURE_WEBAPP_NAME }}" \
              --resource-group rg-qgp-staging \
              --query "{state:state,usageState:usageState,availabilityState:availabilityState}" \
              -o json
            echo ""
            echo "üìã Recent deployment logs:"
            az webapp log show \
              --name "${{ env.AZURE_WEBAPP_NAME }}" \
              --resource-group rg-qgp-staging \
              --output table 2>/dev/null || echo "(no logs available)"
            exit 1
          fi
          
          echo ""
          echo "üéâ Deployment verification PASSED!"

      - name: Deterministic SHA verification with stability gate
        id: sha_verify
        run: |
          # Deterministic verification: polls until SHA matches with N consecutive confirmations
          # This prevents false failures from Azure App Service container swap latency
          
          APP_HOST=$(az webapp show \
            --name "${{ env.AZURE_WEBAPP_NAME }}" \
            --resource-group rg-qgp-staging \
            --query defaultHostName -o tsv)
          APP_URL="https://${APP_HOST}"
          
          echo "APP_HOST=$APP_HOST" >> "$GITHUB_ENV"
          
          # Run deterministic verification script
          # - Polls /api/v1/meta/version until build_sha matches expected
          # - Requires 3 consecutive matching responses (stability gate)
          # - Bounded retries with exponential backoff
          # - Total timeout: 20 minutes (App Service cold starts can exceed 10 min)
          ./scripts/verify_deploy_deterministic.sh \
            --url "$APP_URL" \
            --expected-sha "${{ github.sha }}" \
            --environment "staging" \
            --output "/tmp/verification_evidence.json" \
            --stability 3 \
            --max-attempts 60 \
            --timeout 1200

      - name: Capture runtime evidence
        if: always()
        run: |
          APP_HOST="${{ env.APP_HOST }}"
          if [ -z "$APP_HOST" ]; then
            APP_HOST=$(az webapp show \
              --name "${{ env.AZURE_WEBAPP_NAME }}" \
              --resource-group rg-qgp-staging \
              --query defaultHostName -o tsv)
          fi
          
          # Read verification result
          VERIFY_RESULT="UNKNOWN"
          VERIFY_SHA="N/A"
          VERIFY_STABILITY="0"
          VERIFY_ATTEMPTS="0"
          VERIFY_ELAPSED="0"
          
          if [ -f /tmp/verification_evidence.json ]; then
            VERIFY_RESULT=$(python3 -c 'import json; print(json.load(open("/tmp/verification_evidence.json")).get("verification_result","UNKNOWN"))' 2>/dev/null || echo "UNKNOWN")
            VERIFY_SHA=$(python3 -c 'import json; print(json.load(open("/tmp/verification_evidence.json")).get("final_sha","N/A"))' 2>/dev/null || echo "N/A")
            VERIFY_STABILITY=$(python3 -c 'import json; print(json.load(open("/tmp/verification_evidence.json")).get("stability_confirmations",0))' 2>/dev/null || echo "0")
            VERIFY_ATTEMPTS=$(python3 -c 'import json; print(json.load(open("/tmp/verification_evidence.json")).get("attempts",0))' 2>/dev/null || echo "0")
            VERIFY_ELAPSED=$(python3 -c 'import json; print(json.load(open("/tmp/verification_evidence.json")).get("elapsed_seconds",0))' 2>/dev/null || echo "0")
          fi
          
          # Get container image info (informational only - may be stale during swap)
          RUNNING_IMAGE_RAW=$(az webapp config container show \
            --name "${{ env.AZURE_WEBAPP_NAME }}" \
            --resource-group rg-qgp-staging \
            --query "linuxFxVersion" -o tsv 2>/dev/null || echo "")
          RUNNING_IMAGE="${RUNNING_IMAGE_RAW#DOCKER|}"
          RUNNING_IMAGE_SAFE="${RUNNING_IMAGE#*/}"
          if [ -z "$RUNNING_IMAGE_SAFE" ]; then
            RUNNING_IMAGE_SAFE="not reported"
          fi
          
          # Generate evidence file
          HOST_HASH=$(APP_HOST="$APP_HOST" python3 -c 'import hashlib, os; host=os.environ.get("APP_HOST",""); print(hashlib.sha256(host.encode("utf-8")).hexdigest() if host else "")')
          EVIDENCE_PATH="docs/evidence/DEPLOY_EVIDENCE_staging_${{ github.run_id }}.md"
          
          mkdir -p docs/evidence
          {
            echo "## Deploy Evidence (staging)"
            echo ""
            echo "### Deterministic Verification"
            echo "- verification_result: ${VERIFY_RESULT}"
            echo "- stability_confirmations: ${VERIFY_STABILITY}/3"
            echo "- verification_attempts: ${VERIFY_ATTEMPTS}"
            echo "- verification_elapsed: ${VERIFY_ELAPSED}s"
            echo ""
            echo "### Build Identity"
            echo "- run_id: ${{ github.run_id }}"
            echo "- expected_sha: ${{ github.sha }}"
            echo "- verified_sha: ${VERIFY_SHA}"
            echo "- expected_tag: ${EXPECTED_TAG_SAFE}"
            echo "- expected_digest: ${EXPECTED_DIGEST}"
            echo ""
            echo "### Container Info (informational)"
            echo "- running_image: ${RUNNING_IMAGE_SAFE}"
            echo "- host_sha256: ${HOST_HASH}"
            echo "- timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          } > "$EVIDENCE_PATH"
          
          # Copy JSON evidence if available
          if [ -f /tmp/verification_evidence.json ]; then
            cp /tmp/verification_evidence.json "docs/evidence/DEPLOY_EVIDENCE_staging_${{ github.run_id }}.json"
          fi
          
          echo ""
          echo "‚úÖ Evidence captured to ${EVIDENCE_PATH}"
          
          # Show evidence in job summary
          {
            echo ""
            echo "## üìã Deploy Verification Evidence"
            echo ""
            echo "| Metric | Value |"
            echo "|--------|-------|"
            echo "| **Result** | ${VERIFY_RESULT} |"
            echo "| **Expected SHA** | \`${{ github.sha }}\` |"
            echo "| **Verified SHA** | \`${VERIFY_SHA}\` |"
            echo "| **Stability** | ${VERIFY_STABILITY}/3 consecutive matches |"
            echo "| **Attempts** | ${VERIFY_ATTEMPTS} |"
            echo "| **Time** | ${VERIFY_ELAPSED}s |"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload deploy evidence artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-evidence-staging-${{ github.run_id }}
          path: |
            docs/evidence/DEPLOY_EVIDENCE_staging_${{ github.run_id }}.md
            docs/evidence/DEPLOY_EVIDENCE_staging_${{ github.run_id }}.json

      - name: Deployment summary
        if: always()
        run: |
          {
            echo ""
            echo "## üìä Deployment Result"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"
          if [[ "${{ job.status }}" == "success" ]]; then
            {
              echo "### ‚úÖ STAGING DEPLOYMENT SUCCESSFUL"
              echo ""
              echo "| Item | Value |"
              echo "|------|-------|"
              echo "| **Image** | \`${{ env.IMAGE_NAME }}:${{ github.sha }}\` |"
              echo "| **Health Check** | ‚úÖ Passed with retry |"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            {
              echo "### ‚ùå STAGING DEPLOYMENT FAILED"
              echo ""
              echo "Check the workflow logs for details."
            } >> "$GITHUB_STEP_SUMMARY"
          fi

  # Post-deployment smoke tests
  smoke-tests:
    name: Staging Smoke Tests
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: needs.build-and-deploy.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run smoke tests
        run: |
          APP_URL="https://${{ secrets.AZURE_WEBAPP_NAME }}.azurewebsites.net"
          echo "üß™ Running staging smoke tests"
          
          TESTS_PASSED=0
          TESTS_FAILED=0
          
          # Test 1: Health endpoint
          echo "Test 1: Health endpoint"
          HEALTH=$(curl -s --max-time 30 "$APP_URL/healthz")
          if echo "$HEALTH" | grep -q '"status"'; then
            echo "   ‚úÖ PASSED - Health endpoint returns valid JSON"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "   ‚ùå FAILED - Invalid health response"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi
          
          # Test 2: Readiness endpoint
          echo "Test 2: Readiness endpoint"
          READY=$(curl -s --max-time 30 "$APP_URL/readyz")
          if echo "$READY" | grep -q '"status"'; then
            echo "   ‚úÖ PASSED - Readiness endpoint returns valid JSON"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "   ‚ùå FAILED - Invalid readiness response"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi
          
          # Test 3: API returns 401/403 for unauthenticated requests
          echo "Test 3: API authentication guard"
          AUTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$APP_URL/api/v1/policies")
          if [ "$AUTH_STATUS" = "401" ] || [ "$AUTH_STATUS" = "403" ]; then
            echo "   ‚úÖ PASSED - API correctly rejects unauthenticated requests (HTTP $AUTH_STATUS)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "   ‚ö†Ô∏è INFO - Received HTTP $AUTH_STATUS"
          fi
          
          # Test 4: OpenAPI spec available
          echo "Test 4: OpenAPI specification"
          OPENAPI_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$APP_URL/openapi.json")
          if [ "$OPENAPI_STATUS" = "200" ]; then
            echo "   ‚úÖ PASSED - OpenAPI spec accessible"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "   ‚ö†Ô∏è INFO - OpenAPI spec returned HTTP $OPENAPI_STATUS"
          fi
          
          # Test 5: Docs endpoint
          echo "Test 5: API documentation"
          DOCS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$APP_URL/docs")
          if [ "$DOCS_STATUS" = "200" ]; then
            echo "   ‚úÖ PASSED - API docs accessible"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "   ‚ö†Ô∏è INFO - API docs returned HTTP $DOCS_STATUS"
          fi
          
          echo ""
          echo "üìä Results: $TESTS_PASSED passed, $TESTS_FAILED failed"
          echo ""
          
          if [ $TESTS_FAILED -gt 0 ]; then
            echo "‚ùå Critical smoke tests failed!"
            exit 1
          fi
          
          echo "üéâ All smoke tests passed!"

      - name: Run audit lifecycle E2E (strict if configured)
        env:
          E2E_EMAIL: ${{ secrets.UX_TEST_USER_EMAIL }}
          E2E_PASSWORD: ${{ secrets.UX_TEST_USER_PASSWORD }}
        run: |
          if [ -z "$E2E_EMAIL" ] || [ -z "$E2E_PASSWORD" ]; then
            echo "‚ÑπÔ∏è E2E credentials not configured. Skipping audit lifecycle E2E."
            exit 0
          fi
          python3 -m pip install --upgrade pip
          python3 -m pip install requests
          python3 scripts/smoke/audit_lifecycle_e2e.py \
            --base-url "https://${{ secrets.AZURE_WEBAPP_NAME }}.azurewebsites.net" \
            --email "$E2E_EMAIL" \
            --password "$E2E_PASSWORD" \
            --json

      - name: Smoke test summary
        if: always()
        run: |
          {
            echo "## üß™ Staging Smoke Tests"
            echo ""
            echo "| Test | Status |"
            echo "|------|--------|"
            echo "| Health Endpoint | ‚úÖ |"
            echo "| Readiness Endpoint | ‚úÖ |"
            echo "| Auth Guard | ‚úÖ |"
            echo "| OpenAPI Spec | ‚úÖ |"
            echo "| API Docs | ‚úÖ |"
          } >> "$GITHUB_STEP_SUMMARY"

  # Final notification
  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [build-and-deploy, smoke-tests]
    if: always()
    
    steps:
      - name: Final status
        run: |
          {
            echo "## üìä Staging Deployment Final Status"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"
          
          if [[ "${{ needs.build-and-deploy.result }}" == "success" && "${{ needs.smoke-tests.result }}" == "success" ]]; then
            {
              echo "### ‚úÖ STAGING DEPLOYMENT SUCCESSFUL"
              echo ""
              echo "The staging deployment completed successfully. Ready for production promotion."
              echo ""
            } >> "$GITHUB_STEP_SUMMARY"
            echo "üéâ Staging deployment successful!"
            echo "   Deployment ID: ${{ needs.build-and-deploy.outputs.deployment_id }}"
          else
            {
              echo "### ‚ùå STAGING DEPLOYMENT FAILED"
              echo ""
              echo "| Stage | Result |"
              echo "|-------|--------|"
              echo "| Build & Deploy | ${{ needs.build-and-deploy.result }} |"
              echo "| Smoke Tests | ${{ needs.smoke-tests.result }} |"
              echo ""
            } >> "$GITHUB_STEP_SUMMARY"
            echo "‚ùå Staging deployment failed - check logs above"
          fi

name: Deploy to Azure Staging

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual deployment'
        required: false
        default: 'Manual trigger'

env:
  ACR_NAME: ${{ secrets.ACR_NAME }}
  # DEPRECATED: AZURE_WEBAPP_NAME - Migrated to Azure Container Apps per ADR-0004
  # AZURE_WEBAPP_NAME: ${{ secrets.AZURE_WEBAPP_NAME }}
  AZURE_RESOURCE_GROUP: rg-qgp-staging
  ENVIRONMENT_NAME: staging
  IMAGE_NAME: quality-governance-platform
  # Azure Container Apps configuration (ADR-0004)
  ACA_NAME: qgp-staging
  ACA_ENVIRONMENT: qgp-staging-env
  ACA_FQDN: qgp-staging.ashymushroom-85447e68.uksouth.azurecontainerapps.io
  # Health check configuration - enterprise grade
  HEALTH_CHECK_MAX_ATTEMPTS: 30
  HEALTH_CHECK_INTERVAL: 10

jobs:
  build-and-deploy:
    name: Build and Deploy to Staging
    runs-on: ubuntu-latest
    outputs:
      deployment_id: ${{ steps.generate-id.outputs.deployment_id }}
      image_tag: ${{ steps.build.outputs.image_tag }}
    
    steps:
      - name: Generate deployment ID
        id: generate-id
        run: |
          DEPLOYMENT_ID="staging-$(date +%Y%m%d-%H%M%S)-${{ github.run_number }}"
          echo "deployment_id=$DEPLOYMENT_ID" >> "$GITHUB_OUTPUT"
          echo "üìã Deployment ID: $DEPLOYMENT_ID"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log deployment info
        run: |
          {
            echo "## üöÄ Staging Deployment Started"
            echo ""
            echo "| Item | Value |"
            echo "|------|-------|"
            echo "| **Deployment ID** | ${{ steps.generate-id.outputs.deployment_id }} |"
            echo "| **Trigger** | ${{ github.event_name }} |"
            echo "| **Actor** | ${{ github.actor }} |"
            echo "| **Branch** | ${{ github.ref_name }} |"
            echo "| **Commit** | \`${{ github.sha }}\` |"
            echo "| **Reason** | ${{ github.event.inputs.reason || 'Push to main' }} |"
            echo "| **Timestamp** | $(date -u +"%Y-%m-%dT%H:%M:%SZ") |"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Environment guardrails
        run: |
          # Validate required environment variables for ACA deployment
          if [ -z "$AZURE_RESOURCE_GROUP" ] || [ -z "$ACA_NAME" ] || [ -z "$ENVIRONMENT_NAME" ]; then
            echo "‚ùå Guardrail: required env vars missing"
            echo "   AZURE_RESOURCE_GROUP: ${AZURE_RESOURCE_GROUP:-<missing>}"
            echo "   ACA_NAME: ${ACA_NAME:-<missing>}"
            echo "   ENVIRONMENT_NAME: ${ENVIRONMENT_NAME:-<missing>}"
            exit 1
          fi
          rg_lower=$(echo "$AZURE_RESOURCE_GROUP" | tr '[:upper:]' '[:lower:]')
          aca_lower=$(echo "$ACA_NAME" | tr '[:upper:]' '[:lower:]')
          env_lower=$(echo "$ENVIRONMENT_NAME" | tr '[:upper:]' '[:lower:]')
          if [ "$env_lower" = "production" ]; then
            if echo "$rg_lower$aca_lower" | grep -q "staging"; then
              echo "‚ùå Guardrail: production cannot target staging resources"
              exit 1
            fi
          elif [ "$env_lower" = "staging" ]; then
            if echo "$rg_lower$aca_lower" | grep -q "prod"; then
              echo "‚ùå Guardrail: staging cannot target production resources"
              exit 1
            fi
          else
            echo "‚ùå Guardrail: unknown environment '$ENVIRONMENT_NAME'"
            exit 1
          fi
          echo "‚úÖ Guardrail: environment targeting validated (ACA: $ACA_NAME)"

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: az acr login --name "${{ env.ACR_NAME }}"

      - name: Build and push Docker image
        id: build
        run: |
          IMAGE_TAG="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          IMAGE_LATEST="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:latest"
          
          echo "üî® Building image: $IMAGE_TAG"
          docker build -t "$IMAGE_TAG" -t "$IMAGE_LATEST" .
          
          echo "üì§ Pushing images..."
          docker push "$IMAGE_TAG"
          docker push "$IMAGE_LATEST"
          
          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "IMAGE_TAG=$IMAGE_TAG" >> "$GITHUB_ENV"
          
          echo "‚úÖ Image built and pushed successfully"

      - name: Capture expected image digest
        run: |
          EXPECTED_TAG="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          EXPECTED_DIGESTS=$(az acr repository show-manifests \
            --name "${{ env.ACR_NAME }}" \
            --repository "${{ env.IMAGE_NAME }}" \
            --query "[?tags[?@=='${{ github.sha }}']].digest" \
            -o tsv)
          EXPECTED_DIGESTS_CLEAN=$(printf "%s\n" "$EXPECTED_DIGESTS" | sed '/^$/d' | sort -u)
          EXPECTED_DIGEST_COUNT=$(printf "%s\n" "$EXPECTED_DIGESTS_CLEAN" | wc -l | tr -d ' ')
          if [ "$EXPECTED_DIGEST_COUNT" -ne 1 ]; then
            echo "‚ùå Expected exactly 1 digest for tag ${{ github.sha }}, got $EXPECTED_DIGEST_COUNT"
            exit 1
          fi
          EXPECTED_DIGEST=$(printf "%s\n" "$EXPECTED_DIGESTS_CLEAN" | head -n 1 | tr -d '\r')
          if [ -z "$EXPECTED_DIGEST" ]; then
            echo "‚ùå Failed to resolve image digest for ${EXPECTED_TAG}"
            exit 1
          fi
          case "$EXPECTED_DIGEST" in
            sha256:*) ;;
            *)
              echo "‚ùå Unexpected digest format: $EXPECTED_DIGEST"
              exit 1
              ;;
          esac
          
          IMAGE_DIGEST_REF="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}@${EXPECTED_DIGEST}"
          EXPECTED_TAG_SAFE="${{ env.IMAGE_NAME }}:${{ github.sha }}"
          
          {
            echo "EXPECTED_TAG=$EXPECTED_TAG"
            echo "EXPECTED_DIGEST=$EXPECTED_DIGEST"
            echo "IMAGE_DIGEST_REF=$IMAGE_DIGEST_REF"
            echo "EXPECTED_TAG_SAFE=$EXPECTED_TAG_SAFE"
          } >> "$GITHUB_ENV"

      - name: Preflight validation
        run: |
          {
            echo "## ‚úÖ Preflight Validation"
            echo ""
            echo "| Item | Value |"
            echo "|------|-------|"
            echo "| **Environment** | $ENVIRONMENT_NAME |"
            echo "| **Commit** | \`${{ github.sha }}\` |"
            echo "| **Expected Digest** | \`${EXPECTED_DIGEST}\` |"
          } >> "$GITHUB_STEP_SUMMARY"

      # ==========================================================================
      # AZURE CONTAINER APPS DEPLOYMENT (ADR-0004)
      # Replaces App Service deployment for ACA-only staging
      # ==========================================================================
      
      - name: Deploy to Azure Container Apps
        id: aca_deploy
        run: |
          echo "üöÄ Deploying to Azure Container Apps..."
          echo ""
          echo "Target:"
          echo "  Container App: ${{ env.ACA_NAME }}"
          echo "  Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
          echo "  Image: ${{ env.IMAGE_DIGEST_REF }}"
          echo ""
          
          # Update the container app with new image
          az containerapp update \
            --name "${{ env.ACA_NAME }}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --image "${{ env.IMAGE_DIGEST_REF }}" \
            --set-env-vars \
              BUILD_SHA="${{ github.sha }}" \
              BUILD_TIME="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              APP_ENV="staging" \
            --output none
          
          echo "‚úÖ Container app updated with new image"
          
          # Get the latest revision
          REVISION=$(az containerapp show \
            --name "${{ env.ACA_NAME }}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --query "properties.latestRevisionName" -o tsv)
          
          echo "ACA_REVISION=$REVISION" >> "$GITHUB_ENV"
          echo "revision=$REVISION" >> "$GITHUB_OUTPUT"
          echo ""
          echo "üìã Latest revision: $REVISION"

      - name: Configure ACA secrets from Key Vault
        run: |
          echo "üîê Configuring secrets from Key Vault..."
          
          # Fetch secrets from Key Vault (managed identity handles auth)
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-staging --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-staging --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-staging --name JWT-SECRET-KEY --query value -o tsv)
          STORAGE_CONN=$(az keyvault secret show --vault-name kv-qgp-staging --name AZURE-STORAGE-CONNECTION-STRING --query value -o tsv 2>/dev/null || echo "")
          
          if [ -z "$DB_URL" ]; then
            echo "‚ùå Failed to retrieve DATABASE_URL from Key Vault"
            exit 1
          fi
          echo "‚úÖ Secrets retrieved from Key Vault"
          
          # Update ACA secrets (encrypted at rest)
          az containerapp secret set \
            --name "${{ env.ACA_NAME }}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --secrets \
              "database-url=$DB_URL" \
              "secret-key=$SECRET_KEY_VAL" \
              "jwt-secret-key=$JWT_SECRET_VAL" \
            --output none
          
          # Add storage secret if available
          if [ -n "$STORAGE_CONN" ]; then
            az containerapp secret set \
              --name "${{ env.ACA_NAME }}" \
              --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
              --secrets "azure-storage-conn=$STORAGE_CONN" \
              --output none
          fi
          
          echo "‚úÖ ACA secrets updated"
          
          # Link secrets to environment variables
          az containerapp update \
            --name "${{ env.ACA_NAME }}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --set-env-vars \
              DATABASE_URL=secretref:database-url \
              SECRET_KEY=secretref:secret-key \
              JWT_SECRET_KEY=secretref:jwt-secret-key \
              JWT_ALGORITHM=HS256 \
              JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30 \
              JWT_REFRESH_TOKEN_EXPIRE_DAYS=7 \
              LOG_LEVEL=INFO \
              AZURE_CLIENT_ID="${{ secrets.AZURE_AD_CLIENT_ID }}" \
              AZURE_TENANT_ID="${{ secrets.AZURE_AD_TENANT_ID }}" \
            --output none
          
          # Add storage env var if secret exists
          if [ -n "$STORAGE_CONN" ]; then
            az containerapp update \
              --name "${{ env.ACA_NAME }}" \
              --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
              --set-env-vars AZURE_STORAGE_CONNECTION_STRING=secretref:azure-storage-conn \
              --output none
          fi
          
          echo "‚úÖ Environment variables linked to secrets"

      - name: Wait for ACA revision to be ready
        run: |
          echo "‚è≥ Waiting for new revision to be ready..."
          
          # ACA revisions can take longer than 5 minutes under cold starts.
          MAX_ATTEMPTS=90
          INTERVAL=10
          attempt=1
          
          while [ $attempt -le $MAX_ATTEMPTS ]; do
            REVISION_STATUS=$(az containerapp revision show \
              --name "${{ env.ACA_NAME }}" \
              --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
              --revision "${{ env.ACA_REVISION }}" \
              --query "properties.runningState" -o tsv 2>/dev/null || echo "Unknown")
            
            echo "   Attempt $attempt/$MAX_ATTEMPTS: Revision state = $REVISION_STATUS"
            
            if [ "$REVISION_STATUS" = "Running" ]; then
              echo "‚úÖ Revision is running"
              break
            elif [ "$REVISION_STATUS" = "Failed" ]; then
              echo "‚ùå Revision failed to start"
              az containerapp revision show \
                --name "${{ env.ACA_NAME }}" \
                --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
                --revision "${{ env.ACA_REVISION }}" \
                --query "properties.healthState" -o tsv
              exit 1
            fi
            
            attempt=$((attempt + 1))
            sleep $INTERVAL
          done
          
          if [ $attempt -gt $MAX_ATTEMPTS ]; then
            echo "‚ö†Ô∏è Revision did not reach Running state in time; continuing to downstream verification"
            echo "üìã Revision details:"
            az containerapp revision show \
              --name "${{ env.ACA_NAME }}" \
              --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
              --revision "${{ env.ACA_REVISION }}" \
              --output jsonc || true
          fi

      - name: Run database migrations
        run: |
          echo "üóÉÔ∏è Running migrations via Azure Container Instance..."
          
          # Fetch secrets into variables
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query "passwords[0].value" -o tsv)
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-staging --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-staging --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-staging --name JWT-SECRET-KEY --query value -o tsv)
          STORAGE_CONN=$(az keyvault secret show --vault-name kv-qgp-staging --name AZURE-STORAGE-CONNECTION-STRING --query value -o tsv)
          
          # Validate secrets
          if [ -z "$DB_URL" ]; then
            echo "‚ùå ERROR: Failed to retrieve DATABASE_URL from Key Vault"
            exit 1
          fi
          if [ -z "$STORAGE_CONN" ]; then
            echo "‚ùå ERROR: Failed to retrieve AZURE_STORAGE_CONNECTION_STRING from Key Vault"
            exit 1
          fi
          echo "‚úÖ Successfully retrieved secrets from Key Vault"
          
          CONTAINER_NAME="qgp-migration-${{ github.run_number }}"
          
          # Create container with secure environment variables
          az container create \
            --name $CONTAINER_NAME \
            --resource-group rg-qgp-staging \
            --location westeurope \
            --os-type Linux \
            --image ${{ env.IMAGE_TAG }} \
            --registry-login-server ${{ env.ACR_NAME }}.azurecr.io \
            --registry-username "$ACR_USERNAME" \
            --registry-password "$ACR_PASSWORD" \
            --restart-policy Never \
            --secure-environment-variables \
              DATABASE_URL="$DB_URL" \
              SECRET_KEY="$SECRET_KEY_VAL" \
              JWT_SECRET_KEY="$JWT_SECRET_VAL" \
              AZURE_STORAGE_CONNECTION_STRING="$STORAGE_CONN" \
            --command-line "alembic upgrade head" \
            --cpu 1 \
            --memory 1
          
          echo "‚è≥ Waiting for migration to complete..."
          
          MAX_WAIT=300
          WAITED=0
          while [ $WAITED -lt $MAX_WAIT ]; do
            STATE=$(az container show --name $CONTAINER_NAME --resource-group rg-qgp-staging --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "Running")
            if [ "$STATE" = "Terminated" ]; then
              echo "‚úÖ Migration container terminated after ${WAITED}s"
              break
            fi
            echo "   Migration still running... (${WAITED}s)"
            sleep 10
            WAITED=$((WAITED + 10))
          done
          
          EXIT_CODE=$(az container show --name $CONTAINER_NAME --resource-group rg-qgp-staging --query "containers[0].instanceView.currentState.exitCode" -o tsv)
          
          echo "üìã Migration exit code: $EXIT_CODE"
          echo "üìã Migration logs:"
          az container logs --name $CONTAINER_NAME --resource-group rg-qgp-staging
          
          if [ "$EXIT_CODE" != "0" ]; then
            echo "‚ùå Migration failed!"
            exit 1
          fi
          
          echo "üßπ Cleaning up migration container..."
          az container delete --name $CONTAINER_NAME --resource-group rg-qgp-staging --yes
          echo "‚úÖ Migrations completed successfully"

      - name: Verify ACA deployment with retry
        id: verify
        run: |
          # Use Azure Container Apps FQDN (ADR-0004)
          APP_URL="https://${{ env.ACA_FQDN }}"
          MAX_ATTEMPTS=${{ env.HEALTH_CHECK_MAX_ATTEMPTS }}
          INTERVAL=${{ env.HEALTH_CHECK_INTERVAL }}
          
          echo "üîç Verifying ACA deployment endpoint"
          echo "   Container App: ${{ env.ACA_NAME }}"
          echo "   URL: $APP_URL"
          echo "   Max attempts: $MAX_ATTEMPTS"
          echo "   Interval: ${INTERVAL}s"
          echo "   Total timeout: $((MAX_ATTEMPTS * INTERVAL))s"
          echo ""
          
          # Function to check endpoint with retry
          check_endpoint() {
            local endpoint=$1
            local name=$2
            local attempt=1
            
            echo "üì° Checking $name endpoint: $endpoint"
            
            while [ $attempt -le $MAX_ATTEMPTS ]; do
              HTTP_STATUS=$(curl -s -o /tmp/response.txt -w "%{http_code}" --max-time 30 "$endpoint" 2>/dev/null || echo "000")
              
              if [ "$HTTP_STATUS" = "200" ]; then
                echo "   ‚úÖ Attempt $attempt: $name check PASSED (HTTP $HTTP_STATUS)"
                return 0
              elif [ "$HTTP_STATUS" = "000" ]; then
                echo "   ‚è≥ Attempt $attempt/$MAX_ATTEMPTS: Connection failed, retrying in ${INTERVAL}s..."
              else
                echo "   ‚è≥ Attempt $attempt/$MAX_ATTEMPTS: HTTP $HTTP_STATUS, retrying in ${INTERVAL}s..."
                # After 10 failed attempts, try to capture ACA logs for diagnostics
                if [ $attempt -eq 10 ]; then
                  echo "   üìã Capturing ACA diagnostic logs..."
                  az containerapp logs show \
                    --name "${{ env.ACA_NAME }}" \
                    --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
                    --tail 50 2>/dev/null || true
                fi
              fi
              
              attempt=$((attempt + 1))
              sleep $INTERVAL
            done
            
            echo "   ‚ùå $name check FAILED after $MAX_ATTEMPTS attempts"
            return 1
          }
          
          # Initial wait for app to start (longer wait after Key Vault config)
          echo "‚è≥ Initial wait (60s) for app cold start and Key Vault reference resolution..."
          sleep 60
          
          # Health check with retry
          if ! check_endpoint "$APP_URL/healthz" "Health"; then
            echo ""
            echo "‚ùå ACA DEPLOYMENT VERIFICATION FAILED"
            echo "   Health endpoint did not respond with 200 after $MAX_ATTEMPTS attempts"
            echo ""
            echo "üìã Last response body:"
            cat /tmp/response.txt 2>/dev/null || echo "(empty)"
            echo ""
            echo "üìã Checking Container App status..."
            az containerapp show \
              --name "${{ env.ACA_NAME }}" \
              --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
              --query "{revision:properties.latestRevisionName,state:properties.runningStatus,replicas:properties.template.scale}" \
              -o json
            echo ""
            echo "üìã Recent ACA logs:"
            az containerapp logs show \
              --name "${{ env.ACA_NAME }}" \
              --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
              --tail 30 2>/dev/null || echo "(no logs available)"
            exit 1
          fi
          
          echo ""
          echo "üéâ ACA Deployment verification PASSED!"

      - name: Deterministic SHA verification with stability gate
        id: sha_verify
        run: |
          # Deterministic verification: polls until SHA matches with N consecutive confirmations
          # This prevents false failures from ACA revision rollout latency
          
          # Use ACA FQDN directly (ADR-0004)
          APP_HOST="${{ env.ACA_FQDN }}"
          APP_URL="https://${APP_HOST}"
          
          echo "APP_HOST=$APP_HOST" >> "$GITHUB_ENV"
          
          # Run deterministic verification script
          # - Polls /api/v1/meta/version until build_sha matches expected
          # - Requires 3 consecutive matching responses (stability gate)
          # - Bounded retries with exponential backoff
          # - Total timeout: 10 minutes
          ./scripts/verify_deploy_deterministic.sh \
            --url "$APP_URL" \
            --expected-sha "${{ github.sha }}" \
            --environment "staging" \
            --output "/tmp/verification_evidence.json" \
            --stability 3 \
            --max-attempts 30 \
            --timeout 600

      - name: Capture runtime evidence
        if: always()
        run: |
          # Use ACA FQDN (ADR-0004)
          APP_HOST="${{ env.ACA_FQDN }}"
          
          # Read verification result
          VERIFY_RESULT="UNKNOWN"
          VERIFY_SHA="N/A"
          VERIFY_STABILITY="0"
          VERIFY_ATTEMPTS="0"
          VERIFY_ELAPSED="0"
          
          if [ -f /tmp/verification_evidence.json ]; then
            VERIFY_RESULT=$(python3 -c 'import json; print(json.load(open("/tmp/verification_evidence.json")).get("verification_result","UNKNOWN"))' 2>/dev/null || echo "UNKNOWN")
            VERIFY_SHA=$(python3 -c 'import json; print(json.load(open("/tmp/verification_evidence.json")).get("final_sha","N/A"))' 2>/dev/null || echo "N/A")
            VERIFY_STABILITY=$(python3 -c 'import json; print(json.load(open("/tmp/verification_evidence.json")).get("stability_confirmations",0))' 2>/dev/null || echo "0")
            VERIFY_ATTEMPTS=$(python3 -c 'import json; print(json.load(open("/tmp/verification_evidence.json")).get("attempts",0))' 2>/dev/null || echo "0")
            VERIFY_ELAPSED=$(python3 -c 'import json; print(json.load(open("/tmp/verification_evidence.json")).get("elapsed_seconds",0))' 2>/dev/null || echo "0")
          fi
          
          # Get ACA container image info
          RUNNING_IMAGE=$(az containerapp show \
            --name "${{ env.ACA_NAME }}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --query "properties.template.containers[0].image" -o tsv 2>/dev/null || echo "")
          RUNNING_IMAGE_SAFE="${RUNNING_IMAGE#*/}"
          if [ -z "$RUNNING_IMAGE_SAFE" ]; then
            RUNNING_IMAGE_SAFE="not reported"
          fi
          
          # Get ACA revision info
          ACA_REVISION=$(az containerapp show \
            --name "${{ env.ACA_NAME }}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --query "properties.latestRevisionName" -o tsv 2>/dev/null || echo "unknown")
          
          # Generate evidence file
          HOST_HASH=$(APP_HOST="$APP_HOST" python3 -c 'import hashlib, os; host=os.environ.get("APP_HOST",""); print(hashlib.sha256(host.encode("utf-8")).hexdigest() if host else "")')
          EVIDENCE_PATH="docs/evidence/DEPLOY_EVIDENCE_staging_${{ github.run_id }}.md"
          
          mkdir -p docs/evidence
          {
            echo "## Deploy Evidence (staging - Azure Container Apps)"
            echo ""
            echo "### Platform"
            echo "- platform: Azure Container Apps (ADR-0004)"
            echo "- container_app: ${{ env.ACA_NAME }}"
            echo "- revision: ${ACA_REVISION}"
            echo "- fqdn: ${{ env.ACA_FQDN }}"
            echo ""
            echo "### Deterministic Verification"
            echo "- verification_result: ${VERIFY_RESULT}"
            echo "- stability_confirmations: ${VERIFY_STABILITY}/3"
            echo "- verification_attempts: ${VERIFY_ATTEMPTS}"
            echo "- verification_elapsed: ${VERIFY_ELAPSED}s"
            echo ""
            echo "### Build Identity"
            echo "- run_id: ${{ github.run_id }}"
            echo "- expected_sha: ${{ github.sha }}"
            echo "- verified_sha: ${VERIFY_SHA}"
            echo "- expected_tag: ${EXPECTED_TAG_SAFE}"
            echo "- expected_digest: ${EXPECTED_DIGEST}"
            echo ""
            echo "### Container Info"
            echo "- running_image: ${RUNNING_IMAGE_SAFE}"
            echo "- host_sha256: ${HOST_HASH}"
            echo "- timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          } > "$EVIDENCE_PATH"
          
          # Copy JSON evidence if available
          if [ -f /tmp/verification_evidence.json ]; then
            cp /tmp/verification_evidence.json "docs/evidence/DEPLOY_EVIDENCE_staging_${{ github.run_id }}.json"
          fi
          
          echo ""
          echo "‚úÖ Evidence captured to ${EVIDENCE_PATH}"
          
          # Show evidence in job summary
          {
            echo ""
            echo "## üìã Deploy Verification Evidence"
            echo ""
            echo "| Metric | Value |"
            echo "|--------|-------|"
            echo "| **Result** | ${VERIFY_RESULT} |"
            echo "| **Expected SHA** | \`${{ github.sha }}\` |"
            echo "| **Verified SHA** | \`${VERIFY_SHA}\` |"
            echo "| **Stability** | ${VERIFY_STABILITY}/3 consecutive matches |"
            echo "| **Attempts** | ${VERIFY_ATTEMPTS} |"
            echo "| **Time** | ${VERIFY_ELAPSED}s |"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload deploy evidence artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-evidence-staging-${{ github.run_id }}
          path: |
            docs/evidence/DEPLOY_EVIDENCE_staging_${{ github.run_id }}.md
            docs/evidence/DEPLOY_EVIDENCE_staging_${{ github.run_id }}.json

      - name: Deployment summary
        if: always()
        run: |
          {
            echo ""
            echo "## üìä Deployment Result"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"
          if [[ "${{ job.status }}" == "success" ]]; then
            {
              echo "### ‚úÖ STAGING DEPLOYMENT SUCCESSFUL"
              echo ""
              echo "| Item | Value |"
              echo "|------|-------|"
              echo "| **Image** | \`${{ env.IMAGE_NAME }}:${{ github.sha }}\` |"
              echo "| **Health Check** | ‚úÖ Passed with retry |"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            {
              echo "### ‚ùå STAGING DEPLOYMENT FAILED"
              echo ""
              echo "Check the workflow logs for details."
            } >> "$GITHUB_STEP_SUMMARY"
          fi

  # Post-deployment smoke tests
  smoke-tests:
    name: Staging Smoke Tests
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: needs.build-and-deploy.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run smoke tests
        run: |
          # Use ACA URL (ADR-0004)
          APP_URL="https://${{ env.ACA_FQDN }}"
          echo "üß™ Running staging smoke tests (Azure Container Apps)"
          echo "   Target: $APP_URL"
          
          TESTS_PASSED=0
          TESTS_FAILED=0
          
          # Test 1: Health endpoint
          echo "Test 1: Health endpoint"
          HEALTH=$(curl -s --max-time 30 "$APP_URL/healthz")
          if echo "$HEALTH" | grep -q '"status"'; then
            echo "   ‚úÖ PASSED - Health endpoint returns valid JSON"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "   ‚ùå FAILED - Invalid health response"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi
          
          # Test 2: Readiness endpoint
          echo "Test 2: Readiness endpoint"
          READY=$(curl -s --max-time 30 "$APP_URL/readyz")
          if echo "$READY" | grep -q '"status"'; then
            echo "   ‚úÖ PASSED - Readiness endpoint returns valid JSON"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "   ‚ùå FAILED - Invalid readiness response"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi
          
          # Test 3: API returns 401/403 for unauthenticated requests
          echo "Test 3: API authentication guard"
          AUTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$APP_URL/api/v1/policies")
          if [ "$AUTH_STATUS" = "401" ] || [ "$AUTH_STATUS" = "403" ]; then
            echo "   ‚úÖ PASSED - API correctly rejects unauthenticated requests (HTTP $AUTH_STATUS)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "   ‚ö†Ô∏è INFO - Received HTTP $AUTH_STATUS"
          fi
          
          # Test 4: OpenAPI spec available
          echo "Test 4: OpenAPI specification"
          OPENAPI_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$APP_URL/openapi.json")
          if [ "$OPENAPI_STATUS" = "200" ]; then
            echo "   ‚úÖ PASSED - OpenAPI spec accessible"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "   ‚ö†Ô∏è INFO - OpenAPI spec returned HTTP $OPENAPI_STATUS"
          fi
          
          # Test 5: Docs endpoint
          echo "Test 5: API documentation"
          DOCS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$APP_URL/docs")
          if [ "$DOCS_STATUS" = "200" ]; then
            echo "   ‚úÖ PASSED - API docs accessible"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "   ‚ö†Ô∏è INFO - API docs returned HTTP $DOCS_STATUS"
          fi
          
          echo ""
          echo "üìä Results: $TESTS_PASSED passed, $TESTS_FAILED failed"
          echo ""
          
          if [ $TESTS_FAILED -gt 0 ]; then
            echo "‚ùå Critical smoke tests failed!"
            exit 1
          fi
          
          echo "üéâ All smoke tests passed!"

      - name: Run audit lifecycle E2E (strict if configured)
        env:
          STAGING_E2E_EMAIL: ${{ secrets.STAGING_E2E_EMAIL }}
          STAGING_E2E_PASSWORD: ${{ secrets.STAGING_E2E_PASSWORD }}
        run: |
          if [ -z "$STAGING_E2E_EMAIL" ] || [ -z "$STAGING_E2E_PASSWORD" ]; then
            echo "‚ÑπÔ∏è STAGING_E2E_EMAIL/STAGING_E2E_PASSWORD not configured. Skipping audit lifecycle E2E."
            exit 0
          fi
          python3 -m pip install --upgrade pip
          python3 -m pip install requests
          python3 scripts/smoke/audit_lifecycle_e2e.py \
            --base-url "https://${{ secrets.AZURE_WEBAPP_NAME }}.azurewebsites.net" \
            --email "$STAGING_E2E_EMAIL" \
            --password "$STAGING_E2E_PASSWORD" \
            --json

      - name: Smoke test summary
        if: always()
        run: |
          {
            echo "## üß™ Staging Smoke Tests"
            echo ""
            echo "| Test | Status |"
            echo "|------|--------|"
            echo "| Health Endpoint | ‚úÖ |"
            echo "| Readiness Endpoint | ‚úÖ |"
            echo "| Auth Guard | ‚úÖ |"
            echo "| OpenAPI Spec | ‚úÖ |"
            echo "| API Docs | ‚úÖ |"
          } >> "$GITHUB_STEP_SUMMARY"

  # Post-deployment contract verification (REQUIRED mode - blocking)
  contract-verification:
    name: Contract Verification (REQUIRED)
    runs-on: ubuntu-latest
    needs: [build-and-deploy, smoke-tests]
    if: needs.build-and-deploy.result == 'success' && needs.smoke-tests.result == 'success'
    outputs:
      outcome: ${{ steps.probe.outputs.outcome }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Run Contract Probe (REQUIRED mode)
        id: probe
        env:
          QGP_API_TOKEN: ${{ secrets.QGP_STAGING_READ_TOKEN }}
          PROBE_ENFORCEMENT_MODE: REQUIRED
        run: |
          echo "========================================================================"
          echo "POST-DEPLOY CONTRACT VERIFICATION - Azure Container Apps"
          echo "========================================================================"
          echo ""
          echo "Mode: REQUIRED (blocking - staging should be available after deploy)"
          echo "Deployment ID: ${{ needs.build-and-deploy.outputs.deployment_id }}"
          echo ""
          
          python3 -c "
          import json
          import os
          import sys
          sys.path.insert(0, '.')
          
          from scripts.etl.contract_probe import run_contract_probe, ProbeOutcome, EnforcementMode
          
          result = run_contract_probe('staging', EnforcementMode.REQUIRED)
          
          # Save result with deployment context
          result_dict = result.to_dict()
          result_dict['verification_type'] = 'post-deploy'
          result_dict['deployment_id'] = '${{ needs.build-and-deploy.outputs.deployment_id }}'
          
          with open('probe-result.json', 'w') as f:
              json.dump(result_dict, f, indent=2)
          
          # Output for GitHub Actions
          github_output = os.environ.get('GITHUB_OUTPUT', '')
          if github_output:
              with open(github_output, 'a') as f:
                  f.write(f'outcome={result.outcome.value}\n')
          
          # In REQUIRED mode after deploy:
          # - VERIFIED = success
          # - DEGRADED = pass with warning
          # - UNAVAILABLE = FAIL (staging should be up after deploy)
          # - FAILED = FAIL (contract broken)
          if result.outcome in (ProbeOutcome.FAILED, ProbeOutcome.UNAVAILABLE):
              print(f'‚ùå {result.outcome.value} - deployment verification failed')
              sys.exit(1)
          else:
              print(f'‚úÖ {result.outcome.value} - deployment verified')
              sys.exit(0)
          "

      - name: Contract Verification Summary
        if: always()
        run: |
          if [ ! -f probe-result.json ]; then
            echo "‚ùå No probe result"
            exit 0
          fi
          
          OUTCOME=$(python3 -c "import json; print(json.load(open('probe-result.json')).get('outcome', 'UNKNOWN'))")
          PLATFORM=$(python3 -c "import json; print(json.load(open('probe-result.json')).get('platform', 'unknown'))")
          ENDPOINTS_CHECKED=$(python3 -c "import json; print(json.load(open('probe-result.json')).get('summary', {}).get('endpoints_checked', 0))")
          ENDPOINTS_PASSED=$(python3 -c "import json; print(json.load(open('probe-result.json')).get('summary', {}).get('endpoints_passed', 0))")
          
          {
            echo "## üîç Post-Deploy Contract Verification"
            echo ""
            echo "| Item | Value |"
            echo "|------|-------|"
            echo "| **Platform** | $PLATFORM |"
            echo "| **Outcome** | $OUTCOME |"
            echo "| **Endpoints Checked** | $ENDPOINTS_CHECKED |"
            echo "| **Endpoints Passed** | $ENDPOINTS_PASSED |"
            echo ""
            
            if [ "$OUTCOME" = "VERIFIED" ]; then
              echo "‚úÖ **All contract checks passed** - Deployment verified"
            elif [ "$OUTCOME" = "DEGRADED" ]; then
              echo "‚ö†Ô∏è **Degraded** - Critical checks pass, some non-critical failed"
            elif [ "$OUTCOME" = "UNAVAILABLE" ]; then
              echo "‚ùå **Staging unavailable** - This should not happen after deploy"
            else
              echo "‚ùå **Contract checks failed** - API contract may be broken"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload Contract Probe Results
        uses: actions/upload-artifact@v4
        with:
          name: post-deploy-contract-probe-${{ github.run_id }}
          path: probe-result.json
          retention-days: 90
        if: always()

  # Final notification
  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [build-and-deploy, smoke-tests, contract-verification]
    if: always()
    
    steps:
      - name: Final status
        run: |
          {
            echo "## üìä Staging Deployment Final Status"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"
          
          BUILD_RESULT="${{ needs.build-and-deploy.result }}"
          SMOKE_RESULT="${{ needs.smoke-tests.result }}"
          CONTRACT_RESULT="${{ needs.contract-verification.result }}"
          CONTRACT_OUTCOME="${{ needs.contract-verification.outputs.outcome }}"
          
          if [[ "$BUILD_RESULT" == "success" && "$SMOKE_RESULT" == "success" && "$CONTRACT_RESULT" == "success" ]]; then
            {
              echo "### ‚úÖ STAGING DEPLOYMENT SUCCESSFUL"
              echo ""
              echo "The staging deployment completed successfully with contract verification."
              echo ""
              echo "| Stage | Result |"
              echo "|-------|--------|"
              echo "| Build & Deploy | ‚úÖ $BUILD_RESULT |"
              echo "| Smoke Tests | ‚úÖ $SMOKE_RESULT |"
              echo "| Contract Verification | ‚úÖ $CONTRACT_OUTCOME |"
              echo ""
              echo "Ready for production promotion."
            } >> "$GITHUB_STEP_SUMMARY"
            echo "üéâ Staging deployment successful with contract verification!"
            echo "   Deployment ID: ${{ needs.build-and-deploy.outputs.deployment_id }}"
            echo "   Contract Outcome: $CONTRACT_OUTCOME"
          else
            {
              echo "### ‚ùå STAGING DEPLOYMENT FAILED"
              echo ""
              echo "| Stage | Result |"
              echo "|-------|--------|"
              echo "| Build & Deploy | $BUILD_RESULT |"
              echo "| Smoke Tests | $SMOKE_RESULT |"
              echo "| Contract Verification | $CONTRACT_RESULT ($CONTRACT_OUTCOME) |"
              echo ""
            } >> "$GITHUB_STEP_SUMMARY"
            echo "‚ùå Staging deployment failed - check logs above"
          fi

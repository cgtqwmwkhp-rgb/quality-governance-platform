name: Deploy to Azure Production

# Auto-deploy to production after staging succeeds
on:
  # Auto-trigger after staging deployment
  workflow_run:
    workflows: ["Deploy to Azure Staging"]
    types:
      - completed
    branches:
      - main
  
  # Also allow manual trigger with verification
  workflow_dispatch:
    inputs:
      staging_verified:
        description: 'Confirm staging has been verified'
        required: true
        type: boolean
        default: false
      reason:
        description: 'Reason for production deployment'
        required: true
        type: string
  
  # Also trigger on release
  release:
    types: [published]

env:
  ACR_NAME: ${{ secrets.PROD_ACR_NAME }}
  AZURE_WEBAPP_NAME: ${{ secrets.PROD_AZURE_WEBAPP_NAME }}
  IMAGE_NAME: quality-governance-platform

jobs:
  # Gate: Verify staging succeeded (for auto-trigger) or manual approval
  pre-deployment-checks:
    name: Pre-Deployment Checks
    runs-on: ubuntu-latest
    # Only run if staging succeeded OR manual trigger OR release
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'release'
    outputs:
      approved: ${{ steps.check.outputs.approved }}
    
    steps:
      - name: Validate deployment request
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "‚úÖ Auto-deployment triggered by successful staging"
            echo "Staging workflow: ${{ github.event.workflow_run.html_url }}"
            echo "approved=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "release" ]]; then
            echo "‚úÖ Release-triggered deployment"
            echo "approved=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event.inputs.staging_verified }}" == "true" ]]; then
            echo "‚úÖ Manual deployment with staging verification confirmed"
            echo "Reason: ${{ github.event.inputs.reason }}"
            echo "approved=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Staging verification required!"
            echo "approved=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Log deployment request
        run: |
          echo "## üîê Production Deployment Request" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Trigger** | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Actor** | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Ref** | ${{ github.ref }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **SHA** | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "| **Staging Run** | [View](${{ github.event.workflow_run.html_url }}) |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "| **Reason** | ${{ github.event.inputs.reason || 'Auto-deploy after staging' }} |" >> $GITHUB_STEP_SUMMARY

  build-and-deploy:
    name: Build and Deploy to Production
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.approved == 'true'
    environment:
      name: production
      url: https://app-qgp-prod.azurewebsites.net
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and push Docker image
        run: |
          IMAGE_TAG="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          IMAGE_RELEASE="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:release-${{ github.run_number }}"
          
          echo "Building production image: $IMAGE_TAG"
          docker build -t $IMAGE_TAG -t $IMAGE_RELEASE .
          
          echo "Pushing images..."
          docker push $IMAGE_TAG
          docker push $IMAGE_RELEASE
          
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Create database backup
        run: |
          echo "Creating pre-deployment database backup..."
          # Note: Implement backup strategy based on Azure SQL/PostgreSQL setup
          # az postgres flexible-server backup create ...
          echo "Backup completed (placeholder)"

      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v3
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          images: ${{ env.IMAGE_TAG }}

      - name: Cleanup old migration containers
        continue-on-error: true
        run: |
          echo "Cleaning up old migration containers..."
          # Delete terminated migration containers to free quota
          for container in $(az container list --resource-group rg-qgp-staging --query "[?starts_with(name, 'qgp-migration')].name" -o tsv); do
            STATE=$(az container show --name $container --resource-group rg-qgp-staging --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "Unknown")
            if [ "$STATE" = "Terminated" ] || [ "$STATE" = "Unknown" ]; then
              echo "Deleting container: $container (state: $STATE)"
              az container delete --name $container --resource-group rg-qgp-staging --yes || true
            fi
          done
          echo "Cleanup complete"

      - name: Run database migrations
        continue-on-error: true
        id: migrations
        run: |
          echo "Running migrations via Azure Container Instance..."
          
          # Fetch secrets into variables
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query "passwords[0].value" -o tsv)
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-prod --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name JWT-SECRET-KEY --query value -o tsv)
          
          # Validate secrets
          if [ -z "$DB_URL" ]; then
            echo "‚ö†Ô∏è WARNING: Failed to retrieve DATABASE_URL - skipping migrations"
            echo "migration_status=skipped" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Successfully retrieved secrets from Key Vault"
          
          # Create migration container (with error handling for quota)
          if ! az container create \
            --name qgp-migration-prod-${{ github.run_number }} \
            --resource-group rg-qgp-staging \
            --location westeurope \
            --os-type Linux \
            --image ${{ env.IMAGE_TAG }} \
            --registry-login-server ${{ env.ACR_NAME }}.azurecr.io \
            --registry-username "$ACR_USERNAME" \
            --registry-password "$ACR_PASSWORD" \
            --restart-policy Never \
            --secure-environment-variables \
              DATABASE_URL="$DB_URL" \
              SECRET_KEY="$SECRET_KEY_VAL" \
              JWT_SECRET_KEY="$JWT_SECRET_VAL" \
            --command-line "alembic upgrade head" \
            --cpu 1 \
            --memory 1; then
            echo "‚ö†Ô∏è WARNING: Container quota exceeded - migrations skipped"
            echo "The app is deployed but migrations may need manual execution"
            echo "migration_status=quota_exceeded" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Waiting for migration to complete..."
          
          MAX_WAIT=300
          WAITED=0
          while [ $WAITED -lt $MAX_WAIT ]; do
            STATE=$(az container show --name qgp-migration-prod-${{ github.run_number }} --resource-group rg-qgp-staging --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "Running")
            if [ "$STATE" = "Terminated" ]; then
              echo "Migration container terminated after ${WAITED}s"
              break
            fi
            echo "Migration still running... (${WAITED}s)"
            sleep 10
            WAITED=$((WAITED + 10))
          done
          
          EXIT_CODE=$(az container show --name qgp-migration-prod-${{ github.run_number }} --resource-group rg-qgp-staging --query "containers[0].instanceView.currentState.exitCode" -o tsv || echo "1")
          
          echo "Migration exit code: $EXIT_CODE"
          echo "Migration logs:"
          az container logs --name qgp-migration-prod-${{ github.run_number }} --resource-group rg-qgp-staging || true
          
          if [ "$EXIT_CODE" != "0" ]; then
            echo "‚ö†Ô∏è WARNING: Migration returned non-zero exit code"
            echo "migration_status=failed" >> $GITHUB_OUTPUT
          else
            echo "migration_status=success" >> $GITHUB_OUTPUT
          fi
          
          echo "Cleaning up migration container..."
          az container delete --name qgp-migration-prod-${{ github.run_number }} --resource-group rg-qgp-staging --yes || true

      - name: Verify deployment
        run: |
          echo "Waiting for app to restart..."
          sleep 45
          
          echo "Running production health checks..."
          
          # Health check
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/healthz)
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Health check failed: $HTTP_STATUS"
            exit 1
          fi
          echo "‚úÖ Health check passed"
          
          # Readiness check
          READY_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/readyz)
          if [ "$READY_STATUS" != "200" ]; then
            echo "‚ùå Readiness check failed: $READY_STATUS"
            exit 1
          fi
          echo "‚úÖ Readiness check passed"
          
          # API docs check
          DOCS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/openapi.json)
          if [ "$DOCS_STATUS" != "200" ]; then
            echo "‚ö†Ô∏è OpenAPI docs not accessible: $DOCS_STATUS"
          else
            echo "‚úÖ OpenAPI docs accessible"
          fi
          
          echo "‚úÖ All deployment verification checks passed!"

      - name: Production deployment summary
        run: |
          echo "## üöÄ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image** | ${{ env.IMAGE_TAG }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **URL** | https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net |" >> $GITHUB_STEP_SUMMARY
          echo "| **Deployed By** | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Trigger** | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ‚úÖ Deployed |" >> $GITHUB_STEP_SUMMARY

  # Notify on completion
  notify:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: always()
    
    steps:
      - name: Notify success
        if: needs.build-and-deploy.result == 'success'
        run: |
          echo "üéâ Production deployment successful!"
          echo "Deployed by: ${{ github.actor }}"
          echo "Trigger: ${{ github.event_name }}"
          echo "Commit: ${{ github.sha }}"
          # Add Slack/Teams notification here if configured
      
      - name: Notify failure
        if: needs.build-and-deploy.result == 'failure'
        run: |
          echo "‚ùå Production deployment FAILED!"
          echo "Immediate investigation required."
          echo "Actor: ${{ github.actor }}"
          echo "Commit: ${{ github.sha }}"
          # Add PagerDuty/incident notification here if configured

name: Deploy to Azure Production

# Auto-deploy to production after staging succeeds
on:
  # Auto-trigger after staging deployment
  workflow_run:
    workflows: ["Deploy to Azure Staging"]
    types:
      - completed
    branches:
      - main
  
  # Also allow manual trigger with verification
  workflow_dispatch:
    inputs:
      staging_verified:
        description: 'Confirm staging has been verified'
        required: true
        default: false
      reason:
        description: 'Reason for production deployment'
        required: true
  
  # Also trigger on release
  release:
    types: [published]

env:
  ACR_NAME: ${{ secrets.PROD_ACR_NAME }}
  AZURE_WEBAPP_NAME: ${{ secrets.PROD_AZURE_WEBAPP_NAME }}
  AZURE_RESOURCE_GROUP: rg-qgp-prod
  ENVIRONMENT_NAME: production
  IMAGE_NAME: quality-governance-platform

jobs:
  # Gate: Verify staging succeeded (for auto-trigger) or manual approval
  pre-deployment-checks:
    name: Pre-Deployment Checks
    runs-on: ubuntu-latest
    # Only run if staging succeeded OR manual trigger OR release
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'release'
    outputs:
      approved: ${{ steps.check.outputs.approved }}
    
    steps:
      - name: Validate deployment request
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "‚úÖ Auto-deployment triggered by successful staging"
            echo "Staging workflow: ${{ github.event.workflow_run.html_url }}"
            echo "approved=true" >> "$GITHUB_OUTPUT"
          elif [[ "${{ github.event_name }}" == "release" ]]; then
            echo "‚úÖ Release-triggered deployment"
            echo "approved=true" >> "$GITHUB_OUTPUT"
          elif [[ "${{ github.event.inputs.staging_verified }}" == "true" ]]; then
            echo "‚úÖ Manual deployment with staging verification confirmed"
            echo "Reason: ${{ github.event.inputs.reason }}"
            echo "approved=true" >> "$GITHUB_OUTPUT"
          else
            echo "‚ùå Staging verification required!"
            echo "approved=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi

      - name: Log deployment request
        run: |
          {
            echo "## üîê Production Deployment Request"
            echo ""
            echo "| Item | Value |"
            echo "|------|-------|"
            echo "| **Trigger** | ${{ github.event_name }} |"
            echo "| **Actor** | ${{ github.actor }} |"
            echo "| **Ref** | ${{ github.ref }} |"
            echo "| **SHA** | ${{ github.sha }} |"
            if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
              echo "| **Staging Run** | [View](${{ github.event.workflow_run.html_url }}) |"
            fi
            echo "| **Reason** | ${{ github.event.inputs.reason || 'Auto-deploy after staging' }} |"
          } >> "$GITHUB_STEP_SUMMARY"

  build-and-deploy:
    name: Build and Deploy to Production
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.approved == 'true'
    environment:
      name: production
      url: https://app-qgp-prod.azurewebsites.net
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Environment guardrails
        run: |
          if [ -z "$AZURE_RESOURCE_GROUP" ] || [ -z "$AZURE_WEBAPP_NAME" ] || [ -z "$ENVIRONMENT_NAME" ]; then
            echo "‚ùå Guardrail: required env vars missing"
            exit 1
          fi
          rg_lower=$(echo "$AZURE_RESOURCE_GROUP" | tr '[:upper:]' '[:lower:]')
          app_lower=$(echo "$AZURE_WEBAPP_NAME" | tr '[:upper:]' '[:lower:]')
          env_lower=$(echo "$ENVIRONMENT_NAME" | tr '[:upper:]' '[:lower:]')
          if [ "$env_lower" = "production" ]; then
            if echo "$rg_lower$app_lower" | grep -q "staging"; then
              echo "‚ùå Guardrail: production cannot target staging resources"
              exit 1
            fi
          elif [ "$env_lower" = "staging" ]; then
            if echo "$rg_lower$app_lower" | grep -q "prod"; then
              echo "‚ùå Guardrail: staging cannot target production resources"
              exit 1
            fi
          else
            echo "‚ùå Guardrail: unknown environment '$ENVIRONMENT_NAME'"
            exit 1
          fi
          echo "‚úÖ Guardrail: environment targeting validated"

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and push Docker image
        run: |
          IMAGE_TAG="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          IMAGE_RELEASE="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:release-${{ github.run_number }}"
          
          echo "Building production image: $IMAGE_TAG"
          docker build -t "$IMAGE_TAG" -t "$IMAGE_RELEASE" .
          
          echo "Pushing images..."
          docker push "$IMAGE_TAG"
          docker push "$IMAGE_RELEASE"
          
          echo "IMAGE_TAG=$IMAGE_TAG" >> "$GITHUB_ENV"

      - name: Capture expected image digest
        run: |
          EXPECTED_TAG="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          EXPECTED_DIGESTS=$(az acr repository show-manifests \
            --name "${{ env.ACR_NAME }}" \
            --repository "${{ env.IMAGE_NAME }}" \
            --query "[?tags[?@=='${{ github.sha }}']].digest" \
            -o tsv)
          EXPECTED_DIGESTS_CLEAN=$(printf "%s\n" "$EXPECTED_DIGESTS" | sed '/^$/d' | sort -u)
          EXPECTED_DIGEST_COUNT=$(printf "%s\n" "$EXPECTED_DIGESTS_CLEAN" | wc -l | tr -d ' ')
          if [ "$EXPECTED_DIGEST_COUNT" -ne 1 ]; then
            echo "‚ùå Expected exactly 1 digest for tag ${{ github.sha }}, got $EXPECTED_DIGEST_COUNT"
            exit 1
          fi
          EXPECTED_DIGEST=$(printf "%s\n" "$EXPECTED_DIGESTS_CLEAN" | head -n 1 | tr -d '\r')
          if [ -z "$EXPECTED_DIGEST" ]; then
            echo "‚ùå Failed to resolve image digest for ${EXPECTED_TAG}"
            exit 1
          fi
          case "$EXPECTED_DIGEST" in
            sha256:*) ;;
            *)
              echo "‚ùå Unexpected digest format: $EXPECTED_DIGEST"
              exit 1
              ;;
          esac
          
          IMAGE_DIGEST_REF="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}@${EXPECTED_DIGEST}"
          EXPECTED_TAG_SAFE="${{ env.IMAGE_NAME }}:${{ github.sha }}"
          
          echo "EXPECTED_TAG=$EXPECTED_TAG" >> "$GITHUB_ENV"
          echo "EXPECTED_DIGEST=$EXPECTED_DIGEST" >> "$GITHUB_ENV"
          echo "IMAGE_DIGEST_REF=$IMAGE_DIGEST_REF" >> "$GITHUB_ENV"
          echo "EXPECTED_TAG_SAFE=$EXPECTED_TAG_SAFE" >> "$GITHUB_ENV"

      - name: Preflight validation
        run: |
          {
            echo "## ‚úÖ Preflight Validation"
            echo ""
            echo "| Item | Value |"
            echo "|------|-------|"
            echo "| **Environment** | $ENVIRONMENT_NAME |"
            echo "| **Commit** | \`${{ github.sha }}\` |"
            echo "| **Expected Digest** | \`${EXPECTED_DIGEST}\` |"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Create database backup
        run: |
          echo "Creating pre-deployment database backup..."
          # Note: Implement backup strategy based on Azure SQL/PostgreSQL setup
          # az postgres flexible-server backup create ...
          echo "Backup completed (placeholder)"

      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v3
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          images: ${{ env.IMAGE_DIGEST_REF }}

      - name: Configure App Service environment
        run: |
          echo "üîß Configuring App Service with Azure AD settings..."
          
          # Fetch secrets from Key Vault
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-prod --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name JWT-SECRET-KEY --query value -o tsv)
          
          # Configure app settings
          az webapp config appsettings set \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group $AZURE_RESOURCE_GROUP \
            --settings \
              APP_ENV="production" \
              BUILD_SHA="${{ github.sha }}" \
              BUILD_TIME="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              DATABASE_URL="$DB_URL" \
              SECRET_KEY="$SECRET_KEY_VAL" \
              JWT_SECRET_KEY="$JWT_SECRET_VAL" \
              JWT_ALGORITHM="HS256" \
              JWT_ACCESS_TOKEN_EXPIRE_MINUTES="30" \
              JWT_REFRESH_TOKEN_EXPIRE_DAYS="7" \
              LOG_LEVEL="INFO" \
              DATABASE_ECHO="false" \
              WEBSITES_PORT="8000" \
              AZURE_CLIENT_ID="${{ secrets.AZURE_AD_CLIENT_ID }}" \
              AZURE_TENANT_ID="${{ secrets.AZURE_AD_TENANT_ID }}" \
            --output none
          
          echo "‚úÖ Application settings configured"

      - name: Cleanup old migration containers
        continue-on-error: true
        run: |
          echo "Cleaning up old migration containers..."
          # Delete terminated migration containers to free quota
          for container in $(az container list --resource-group $AZURE_RESOURCE_GROUP --query "[?starts_with(name, 'qgp-migration')].name" -o tsv); do
            STATE=$(az container show --name $container --resource-group $AZURE_RESOURCE_GROUP --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "Unknown")
            if [ "$STATE" = "Terminated" ] || [ "$STATE" = "Unknown" ]; then
              echo "Deleting container: $container (state: $STATE)"
              az container delete --name $container --resource-group $AZURE_RESOURCE_GROUP --yes || true
            fi
          done
          echo "Cleanup complete"

      - name: Run database migrations
        id: migrations
        run: |
          echo "Running migrations via Azure Container Instance..."
          
          # Fetch secrets into variables
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query "passwords[0].value" -o tsv)
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-prod --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name JWT-SECRET-KEY --query value -o tsv)
          
          # Validate secrets - FAIL if missing (no silent skip)
          if [ -z "$DB_URL" ]; then
            echo "‚ùå ERROR: Failed to retrieve DATABASE_URL from Key Vault"
            echo "migration_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "Successfully retrieved secrets from Key Vault"
          
          # Create migration container (with error handling for quota)
          if ! az container create \
            --name qgp-migration-prod-${{ github.run_number }} \
            --resource-group $AZURE_RESOURCE_GROUP \
            --location westeurope \
            --os-type Linux \
            --image ${{ env.IMAGE_TAG }} \
            --registry-login-server ${{ env.ACR_NAME }}.azurecr.io \
            --registry-username "$ACR_USERNAME" \
            --registry-password "$ACR_PASSWORD" \
            --restart-policy Never \
            --secure-environment-variables \
              DATABASE_URL="$DB_URL" \
              SECRET_KEY="$SECRET_KEY_VAL" \
              JWT_SECRET_KEY="$JWT_SECRET_VAL" \
            --command-line "alembic upgrade head" \
            --cpu 1 \
            --memory 1; then
            echo "‚ö†Ô∏è WARNING: Container quota exceeded - migrations skipped"
            echo "The app is deployed but migrations may need manual execution"
            echo "migration_status=quota_exceeded" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Waiting for migration to complete..."
          
          MAX_WAIT=300
          WAITED=0
          while [ $WAITED -lt $MAX_WAIT ]; do
            STATE=$(az container show --name qgp-migration-prod-${{ github.run_number }} --resource-group $AZURE_RESOURCE_GROUP --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "Running")
            if [ "$STATE" = "Terminated" ]; then
              echo "Migration container terminated after ${WAITED}s"
              break
            fi
            echo "Migration still running... (${WAITED}s)"
            sleep 10
            WAITED=$((WAITED + 10))
          done
          
          EXIT_CODE=$(az container show --name qgp-migration-prod-${{ github.run_number }} --resource-group $AZURE_RESOURCE_GROUP --query "containers[0].instanceView.currentState.exitCode" -o tsv || echo "1")
          
          echo "Migration exit code: $EXIT_CODE"
          echo "Migration logs:"
          az container logs --name qgp-migration-prod-${{ github.run_number }} --resource-group $AZURE_RESOURCE_GROUP || true
          
          if [ "$EXIT_CODE" != "0" ]; then
            echo "‚ùå ERROR: Migration failed with exit code $EXIT_CODE"
            echo "migration_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "migration_status=success" >> $GITHUB_OUTPUT
          
          echo "Cleaning up migration container..."
          az container delete --name qgp-migration-prod-${{ github.run_number }} --resource-group $AZURE_RESOURCE_GROUP --yes || true

      - name: Verify migration revision
        run: |
          echo "Verifying database migration revision matches repo head..."
          
          # Get expected head revision from repo
          EXPECTED_HEAD=$(grep -r "^revision = " alembic/versions/ | grep -v down_rev | tail -1 | sed "s/.*revision = '\([^']*\)'.*/\1/")
          echo "Expected head revision: $EXPECTED_HEAD"
          
          # Create a container to check current revision
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query "passwords[0].value" -o tsv)
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-prod --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name JWT-SECRET-KEY --query value -o tsv)
          
          az container create \
            --name qgp-revision-check-${{ github.run_number }} \
            --resource-group $AZURE_RESOURCE_GROUP \
            --location westeurope \
            --os-type Linux \
            --image ${{ env.IMAGE_TAG }} \
            --registry-login-server ${{ env.ACR_NAME }}.azurecr.io \
            --registry-username "$ACR_USERNAME" \
            --registry-password "$ACR_PASSWORD" \
            --restart-policy Never \
            --secure-environment-variables \
              DATABASE_URL="$DB_URL" \
              SECRET_KEY="$SECRET_KEY_VAL" \
              JWT_SECRET_KEY="$JWT_SECRET_VAL" \
            --command-line "alembic current" \
            --cpu 1 \
            --memory 1
          
          # Wait for completion
          sleep 30
          MAX_WAIT=60
          WAITED=0
          while [ $WAITED -lt $MAX_WAIT ]; do
            STATE=$(az container show --name qgp-revision-check-${{ github.run_number }} --resource-group $AZURE_RESOURCE_GROUP --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "Running")
            if [ "$STATE" = "Terminated" ]; then
              break
            fi
            sleep 5
            WAITED=$((WAITED + 5))
          done
          
          CURRENT_REV=$(az container logs --name qgp-revision-check-${{ github.run_number }} --resource-group $AZURE_RESOURCE_GROUP 2>/dev/null | grep -o '[a-z0-9_]*' | tail -1 || echo "unknown")
          echo "Current DB revision: $CURRENT_REV"
          
          # Cleanup
          az container delete --name qgp-revision-check-${{ github.run_number }} --resource-group $AZURE_RESOURCE_GROUP --yes || true
          
          # Assert revision matches (note: alembic current may output multiple lines)
          if echo "$CURRENT_REV" | grep -q "$EXPECTED_HEAD"; then
            echo "‚úÖ Database revision matches expected head"
          else
            echo "‚ö†Ô∏è WARNING: Database revision may not match expected head"
            echo "Expected: $EXPECTED_HEAD"
            echo "Current output: $CURRENT_REV"
            echo "This may indicate migration drift - manual verification recommended"
          fi

      - name: Verify deployment - Health checks
        run: |
          echo "Waiting for app to restart..."
          sleep 45
          
          echo "Running production health checks..."
          
          # Health check
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/healthz)
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Health check failed: $HTTP_STATUS"
            exit 1
          fi
          echo "‚úÖ Health check passed"
          
          # Readiness check
          READY_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/readyz)
          if [ "$READY_STATUS" != "200" ]; then
            echo "‚ùå Readiness check failed: $READY_STATUS"
            exit 1
          fi
          echo "‚úÖ Readiness check passed"
          
          # API docs check
          DOCS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/openapi.json)
          if [ "$DOCS_STATUS" != "200" ]; then
            echo "‚ö†Ô∏è OpenAPI docs not accessible: $DOCS_STATUS"
          else
            echo "‚úÖ OpenAPI docs accessible"
          fi
          
          echo "‚úÖ Health checks passed!"

      - name: Capture runtime evidence and enforce determinism
        run: |
          APP_HOST=$(az webapp show \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group $AZURE_RESOURCE_GROUP \
            --query defaultHostName -o tsv)
          APP_URL="https://${APP_HOST}"
          
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "${APP_URL}/healthz")
          
          META_STATUS=$(curl -s -o /tmp/meta.json -w "%{http_code}" --max-time 30 "${APP_URL}/api/v1/meta/version")
          if [ "$META_STATUS" != "200" ]; then
            echo "‚ùå meta/version endpoint failed with HTTP ${META_STATUS}"
            exit 1
          fi
          
          BUILD_SHA=$(python3 -c 'import json; print(json.load(open("/tmp/meta.json")).get("build_sha",""))')
          
          RUNNING_IMAGE_RAW=$(az webapp config container show \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group $AZURE_RESOURCE_GROUP \
            --query "linuxFxVersion" -o tsv)
          RUNNING_IMAGE="${RUNNING_IMAGE_RAW#DOCKER|}"
          RUNNING_IMAGE_SAFE=$(echo "$RUNNING_IMAGE" | sed -E 's#^[^/]+/##')
          
          if [ -z "$RUNNING_IMAGE" ]; then
            echo "‚ö†Ô∏è running image not reported; skipping digest/tag comparison"
          elif echo "$RUNNING_IMAGE" | grep -q "@sha256:"; then
            RUNNING_DIGEST=$(echo "$RUNNING_IMAGE" | sed 's/.*@//')
            if [ "$RUNNING_DIGEST" != "$EXPECTED_DIGEST" ]; then
              echo "‚ùå running digest mismatch: expected ${EXPECTED_DIGEST}, got ${RUNNING_DIGEST}"
              exit 1
            fi
          elif echo "$RUNNING_IMAGE" | grep -q ":"; then
            RUNNING_TAG=$(echo "$RUNNING_IMAGE_SAFE" | awk -F: '{print $NF}')
            if [ "$RUNNING_TAG" != "${{ github.sha }}" ]; then
              echo "‚ùå running tag mismatch: expected ${{ github.sha }}, got ${RUNNING_TAG}"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è running image format unrecognized; skipping digest/tag comparison"
          fi
          
          if [ "$BUILD_SHA" != "${{ github.sha }}" ]; then
            echo "‚ùå build_sha mismatch: expected ${{ github.sha }}, got ${BUILD_SHA}"
            exit 1
          fi
          
          EVIDENCE_PATH="docs/evidence/DEPLOY_EVIDENCE_production_${{ github.run_id }}.md"
          HOST_HASH=$(APP_HOST="$APP_HOST" python3 -c 'import hashlib, os; host=os.environ.get("APP_HOST",""); print(hashlib.sha256(host.encode("utf-8")).hexdigest() if host else "")')
          cat <<EOF > "$EVIDENCE_PATH"
          ## Deploy Evidence (production)
          
          - run_id: ${{ github.run_id }}
          - sha: ${{ github.sha }}
          - expected_tag: ${EXPECTED_TAG_SAFE}
          - expected_digest: ${EXPECTED_DIGEST}
          - running_image: ${RUNNING_IMAGE_SAFE}
          - meta_version_build_sha: ${BUILD_SHA}
          - healthz_status: ${HEALTH_STATUS}
          - host_sha256: ${HOST_HASH}
          EOF

      - name: Upload deploy evidence artifact
        uses: actions/upload-artifact@v4
        with:
          name: deploy-evidence-production-${{ github.run_id }}
          path: docs/evidence/DEPLOY_EVIDENCE_production_${{ github.run_id }}.md

      - name: Verify deployment - Security checks (Stage 4)
        run: |
          echo "Running post-deployment security verification..."
          PROD_URL="https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
          
          # Test 1: Auth required for incidents (no email filter)
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL/api/v1/incidents/")
          if [ "$STATUS" != "401" ]; then
            echo "‚ùå SECURITY ISSUE: Incidents accessible without auth (got $STATUS, expected 401)"
            exit 1
          fi
          echo "‚úÖ Auth required for incidents"
          
          # Test 2: Auth required for incidents WITH email filter (CVE fix verification)
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL/api/v1/incidents/?reporter_email=test@example.com")
          if [ "$STATUS" != "401" ]; then
            echo "‚ùå CRITICAL SECURITY ISSUE: Email filter bypass detected (got $STATUS, expected 401)"
            exit 1
          fi
          echo "‚úÖ CVE fix verified: Auth required for incidents with email filter"
          
          # Test 3: Auth required for complaints WITH email filter
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL/api/v1/complaints/?complainant_email=test@example.com")
          if [ "$STATUS" != "401" ]; then
            echo "‚ùå CRITICAL SECURITY ISSUE: Email filter bypass detected (got $STATUS, expected 401)"
            exit 1
          fi
          echo "‚úÖ CVE fix verified: Auth required for complaints with email filter"
          
          # Test 4: Auth required for RTAs WITH email filter
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL/api/v1/rtas/?reporter_email=test@example.com")
          if [ "$STATUS" != "401" ]; then
            echo "‚ùå CRITICAL SECURITY ISSUE: Email filter bypass detected (got $STATUS, expected 401)"
            exit 1
          fi
          echo "‚úÖ CVE fix verified: Auth required for RTAs with email filter"
          
          # Test 5: Security headers present
          HEADERS=$(curl -sI "$PROD_URL/healthz")
          if ! echo "$HEADERS" | grep -qi "x-content-type-options"; then
            echo "‚ö†Ô∏è Warning: X-Content-Type-Options header missing"
          else
            echo "‚úÖ Security headers present"
          fi
          
          # Test 6: Rate limit headers present
          HEADERS=$(curl -sI "$PROD_URL/api/v1/incidents/")
          if echo "$HEADERS" | grep -qi "x-ratelimit"; then
            echo "‚úÖ Rate limiting active"
          else
            echo "‚ö†Ô∏è Warning: Rate limit headers not found (may be configured differently)"
          fi
          
          echo ""
          echo "‚úÖ All security verification checks passed!"

      - name: Production deployment summary
        run: |
          echo "## üöÄ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image** | ${{ env.IMAGE_NAME }}:${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Deployed By** | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Trigger** | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ‚úÖ Deployed |" >> $GITHUB_STEP_SUMMARY

  # Notify on completion
  notify:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: always()
    
    steps:
      - name: Notify success
        if: needs.build-and-deploy.result == 'success'
        run: |
          echo "üéâ Production deployment successful!"
          echo "Deployed by: ${{ github.actor }}"
          echo "Trigger: ${{ github.event_name }}"
          echo "Commit: ${{ github.sha }}"
          # Add Slack/Teams notification here if configured
      
      - name: Notify failure
        if: needs.build-and-deploy.result == 'failure'
        run: |
          echo "‚ùå Production deployment FAILED!"
          echo "Immediate investigation required."
          echo "Actor: ${{ github.actor }}"
          echo "Commit: ${{ github.sha }}"
          # Add PagerDuty/incident notification here if configured

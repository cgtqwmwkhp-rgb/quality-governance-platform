name: Deploy to Azure Production

# Auto-deploy to production after staging succeeds
on:
  # Auto-trigger after staging deployment
  workflow_run:
    workflows: ["Deploy to Azure Staging"]
    types:
      - completed
    branches:
      - main
  
  # Also allow manual trigger with verification
  workflow_dispatch:
    inputs:
      staging_verified:
        description: 'Confirm staging has been verified'
        required: true
        type: boolean
        default: false
      reason:
        description: 'Reason for production deployment'
        required: true
        type: string
  
  # Also trigger on release
  release:
    types: [published]

env:
  ACR_NAME: ${{ secrets.PROD_ACR_NAME }}
  AZURE_WEBAPP_NAME: ${{ secrets.PROD_AZURE_WEBAPP_NAME }}
  IMAGE_NAME: quality-governance-platform

jobs:
  # Gate: Verify staging succeeded (for auto-trigger) or manual approval
  pre-deployment-checks:
    name: Pre-Deployment Checks
    runs-on: ubuntu-latest
    # Only run if staging succeeded OR manual trigger OR release
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'release'
    outputs:
      approved: ${{ steps.check.outputs.approved }}
    
    steps:
      - name: Validate deployment request
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "‚úÖ Auto-deployment triggered by successful staging"
            echo "Staging workflow: ${{ github.event.workflow_run.html_url }}"
            echo "approved=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "release" ]]; then
            echo "‚úÖ Release-triggered deployment"
            echo "approved=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event.inputs.staging_verified }}" == "true" ]]; then
            echo "‚úÖ Manual deployment with staging verification confirmed"
            echo "Reason: ${{ github.event.inputs.reason }}"
            echo "approved=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Staging verification required!"
            echo "approved=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Log deployment request
        run: |
          echo "## üîê Production Deployment Request" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Trigger** | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Actor** | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Ref** | ${{ github.ref }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **SHA** | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "| **Staging Run** | [View](${{ github.event.workflow_run.html_url }}) |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "| **Reason** | ${{ github.event.inputs.reason || 'Auto-deploy after staging' }} |" >> $GITHUB_STEP_SUMMARY

  build-and-deploy:
    name: Build and Deploy to Production
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.approved == 'true'
    environment:
      name: production
      url: https://app-qgp-prod.azurewebsites.net
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and push Docker image
        run: |
          IMAGE_TAG="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          IMAGE_RELEASE="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:release-${{ github.run_number }}"
          
          echo "Building production image: $IMAGE_TAG"
          docker build -t $IMAGE_TAG -t $IMAGE_RELEASE .
          
          echo "Pushing images..."
          docker push $IMAGE_TAG
          docker push $IMAGE_RELEASE
          
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Create database backup
        run: |
          echo "Creating pre-deployment database backup..."
          # Note: Implement backup strategy based on Azure SQL/PostgreSQL setup
          # az postgres flexible-server backup create ...
          echo "Backup completed (placeholder)"

      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v3
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          images: ${{ env.IMAGE_TAG }}

      - name: Configure App Service environment
        run: |
          echo "üîß Configuring App Service with Azure AD settings..."
          
          # Fetch secrets from Key Vault
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-prod --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name JWT-SECRET-KEY --query value -o tsv)
          
          # Configure app settings
          az webapp config appsettings set \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group rg-qgp-staging \
            --settings \
              APP_ENV="production" \
              DATABASE_URL="$DB_URL" \
              SECRET_KEY="$SECRET_KEY_VAL" \
              JWT_SECRET_KEY="$JWT_SECRET_VAL" \
              JWT_ALGORITHM="HS256" \
              JWT_ACCESS_TOKEN_EXPIRE_MINUTES="30" \
              JWT_REFRESH_TOKEN_EXPIRE_DAYS="7" \
              LOG_LEVEL="INFO" \
              DATABASE_ECHO="false" \
              WEBSITES_PORT="8000" \
              AZURE_CLIENT_ID="${{ secrets.AZURE_AD_CLIENT_ID }}" \
              AZURE_TENANT_ID="${{ secrets.AZURE_AD_TENANT_ID }}" \
            --output none
          
          echo "‚úÖ Application settings configured"

      - name: Cleanup old migration containers
        continue-on-error: true
        run: |
          echo "Cleaning up old migration containers..."
          # Delete terminated migration containers to free quota
          for container in $(az container list --resource-group rg-qgp-staging --query "[?starts_with(name, 'qgp-migration')].name" -o tsv); do
            STATE=$(az container show --name $container --resource-group rg-qgp-staging --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "Unknown")
            if [ "$STATE" = "Terminated" ] || [ "$STATE" = "Unknown" ]; then
              echo "Deleting container: $container (state: $STATE)"
              az container delete --name $container --resource-group rg-qgp-staging --yes || true
            fi
          done
          echo "Cleanup complete"

      - name: Run database migrations
        id: migrations
        run: |
          echo "Running migrations via Azure Container Instance..."
          
          # Fetch secrets into variables
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query "passwords[0].value" -o tsv)
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-prod --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name JWT-SECRET-KEY --query value -o tsv)
          
          # Validate secrets - FAIL if missing (no silent skip)
          if [ -z "$DB_URL" ]; then
            echo "‚ùå ERROR: Failed to retrieve DATABASE_URL from Key Vault"
            echo "migration_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "Successfully retrieved secrets from Key Vault"
          
          # Create migration container (with error handling for quota)
          if ! az container create \
            --name qgp-migration-prod-${{ github.run_number }} \
            --resource-group rg-qgp-staging \
            --location westeurope \
            --os-type Linux \
            --image ${{ env.IMAGE_TAG }} \
            --registry-login-server ${{ env.ACR_NAME }}.azurecr.io \
            --registry-username "$ACR_USERNAME" \
            --registry-password "$ACR_PASSWORD" \
            --restart-policy Never \
            --secure-environment-variables \
              DATABASE_URL="$DB_URL" \
              SECRET_KEY="$SECRET_KEY_VAL" \
              JWT_SECRET_KEY="$JWT_SECRET_VAL" \
            --command-line "alembic upgrade head" \
            --cpu 1 \
            --memory 1; then
            echo "‚ö†Ô∏è WARNING: Container quota exceeded - migrations skipped"
            echo "The app is deployed but migrations may need manual execution"
            echo "migration_status=quota_exceeded" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Waiting for migration to complete..."
          
          MAX_WAIT=300
          WAITED=0
          while [ $WAITED -lt $MAX_WAIT ]; do
            STATE=$(az container show --name qgp-migration-prod-${{ github.run_number }} --resource-group rg-qgp-staging --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "Running")
            if [ "$STATE" = "Terminated" ]; then
              echo "Migration container terminated after ${WAITED}s"
              break
            fi
            echo "Migration still running... (${WAITED}s)"
            sleep 10
            WAITED=$((WAITED + 10))
          done
          
          EXIT_CODE=$(az container show --name qgp-migration-prod-${{ github.run_number }} --resource-group rg-qgp-staging --query "containers[0].instanceView.currentState.exitCode" -o tsv || echo "1")
          
          echo "Migration exit code: $EXIT_CODE"
          echo "Migration logs:"
          az container logs --name qgp-migration-prod-${{ github.run_number }} --resource-group rg-qgp-staging || true
          
          if [ "$EXIT_CODE" != "0" ]; then
            echo "‚ùå ERROR: Migration failed with exit code $EXIT_CODE"
            echo "migration_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "migration_status=success" >> $GITHUB_OUTPUT
          
          echo "Cleaning up migration container..."
          az container delete --name qgp-migration-prod-${{ github.run_number }} --resource-group rg-qgp-staging --yes || true

      - name: Verify migration revision
        run: |
          echo "Verifying database migration revision matches repo head..."
          
          # Get expected head revision from repo
          EXPECTED_HEAD=$(grep -r "^revision = " alembic/versions/ | grep -v down_rev | tail -1 | sed "s/.*revision = '\([^']*\)'.*/\1/")
          echo "Expected head revision: $EXPECTED_HEAD"
          
          # Create a container to check current revision
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query "passwords[0].value" -o tsv)
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-prod --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name JWT-SECRET-KEY --query value -o tsv)
          
          az container create \
            --name qgp-revision-check-${{ github.run_number }} \
            --resource-group rg-qgp-staging \
            --location westeurope \
            --os-type Linux \
            --image ${{ env.IMAGE_TAG }} \
            --registry-login-server ${{ env.ACR_NAME }}.azurecr.io \
            --registry-username "$ACR_USERNAME" \
            --registry-password "$ACR_PASSWORD" \
            --restart-policy Never \
            --secure-environment-variables \
              DATABASE_URL="$DB_URL" \
              SECRET_KEY="$SECRET_KEY_VAL" \
              JWT_SECRET_KEY="$JWT_SECRET_VAL" \
            --command-line "alembic current" \
            --cpu 1 \
            --memory 1
          
          # Wait for completion
          sleep 30
          MAX_WAIT=60
          WAITED=0
          while [ $WAITED -lt $MAX_WAIT ]; do
            STATE=$(az container show --name qgp-revision-check-${{ github.run_number }} --resource-group rg-qgp-staging --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "Running")
            if [ "$STATE" = "Terminated" ]; then
              break
            fi
            sleep 5
            WAITED=$((WAITED + 5))
          done
          
          CURRENT_REV=$(az container logs --name qgp-revision-check-${{ github.run_number }} --resource-group rg-qgp-staging 2>/dev/null | grep -o '[a-z0-9_]*' | tail -1 || echo "unknown")
          echo "Current DB revision: $CURRENT_REV"
          
          # Cleanup
          az container delete --name qgp-revision-check-${{ github.run_number }} --resource-group rg-qgp-staging --yes || true
          
          # Assert revision matches (note: alembic current may output multiple lines)
          if echo "$CURRENT_REV" | grep -q "$EXPECTED_HEAD"; then
            echo "‚úÖ Database revision matches expected head"
          else
            echo "‚ö†Ô∏è WARNING: Database revision may not match expected head"
            echo "Expected: $EXPECTED_HEAD"
            echo "Current output: $CURRENT_REV"
            echo "This may indicate migration drift - manual verification recommended"
          fi

      - name: Verify deployment - Health checks
        run: |
          echo "Waiting for app to restart..."
          sleep 45
          
          echo "Running production health checks..."
          
          # Health check
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/healthz)
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Health check failed: $HTTP_STATUS"
            exit 1
          fi
          echo "‚úÖ Health check passed"
          
          # Readiness check
          READY_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/readyz)
          if [ "$READY_STATUS" != "200" ]; then
            echo "‚ùå Readiness check failed: $READY_STATUS"
            exit 1
          fi
          echo "‚úÖ Readiness check passed"
          
          # API docs check
          DOCS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/openapi.json)
          if [ "$DOCS_STATUS" != "200" ]; then
            echo "‚ö†Ô∏è OpenAPI docs not accessible: $DOCS_STATUS"
          else
            echo "‚úÖ OpenAPI docs accessible"
          fi
          
          echo "‚úÖ Health checks passed!"

      - name: Verify deployment - Security checks (Stage 4)
        run: |
          echo "Running post-deployment security verification..."
          PROD_URL="https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
          
          # Test 1: Auth required for incidents (no email filter)
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL/api/v1/incidents/")
          if [ "$STATUS" != "401" ]; then
            echo "‚ùå SECURITY ISSUE: Incidents accessible without auth (got $STATUS, expected 401)"
            exit 1
          fi
          echo "‚úÖ Auth required for incidents"
          
          # Test 2: Auth required for incidents WITH email filter (CVE fix verification)
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL/api/v1/incidents/?reporter_email=test@example.com")
          if [ "$STATUS" != "401" ]; then
            echo "‚ùå CRITICAL SECURITY ISSUE: Email filter bypass detected (got $STATUS, expected 401)"
            exit 1
          fi
          echo "‚úÖ CVE fix verified: Auth required for incidents with email filter"
          
          # Test 3: Auth required for complaints WITH email filter
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL/api/v1/complaints/?complainant_email=test@example.com")
          if [ "$STATUS" != "401" ]; then
            echo "‚ùå CRITICAL SECURITY ISSUE: Email filter bypass detected (got $STATUS, expected 401)"
            exit 1
          fi
          echo "‚úÖ CVE fix verified: Auth required for complaints with email filter"
          
          # Test 4: Auth required for RTAs WITH email filter
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL/api/v1/rtas/?reporter_email=test@example.com")
          if [ "$STATUS" != "401" ]; then
            echo "‚ùå CRITICAL SECURITY ISSUE: Email filter bypass detected (got $STATUS, expected 401)"
            exit 1
          fi
          echo "‚úÖ CVE fix verified: Auth required for RTAs with email filter"
          
          # Test 5: Security headers present
          HEADERS=$(curl -sI "$PROD_URL/healthz")
          if ! echo "$HEADERS" | grep -qi "x-content-type-options"; then
            echo "‚ö†Ô∏è Warning: X-Content-Type-Options header missing"
          else
            echo "‚úÖ Security headers present"
          fi
          
          # Test 6: Rate limit headers present
          HEADERS=$(curl -sI "$PROD_URL/api/v1/incidents/")
          if echo "$HEADERS" | grep -qi "x-ratelimit"; then
            echo "‚úÖ Rate limiting active"
          else
            echo "‚ö†Ô∏è Warning: Rate limit headers not found (may be configured differently)"
          fi
          
          echo ""
          echo "‚úÖ All security verification checks passed!"

      - name: Production deployment summary
        run: |
          echo "## üöÄ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image** | ${{ env.IMAGE_TAG }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **URL** | https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net |" >> $GITHUB_STEP_SUMMARY
          echo "| **Deployed By** | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Trigger** | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ‚úÖ Deployed |" >> $GITHUB_STEP_SUMMARY

  # Notify on completion
  notify:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: always()
    
    steps:
      - name: Notify success
        if: needs.build-and-deploy.result == 'success'
        run: |
          echo "üéâ Production deployment successful!"
          echo "Deployed by: ${{ github.actor }}"
          echo "Trigger: ${{ github.event_name }}"
          echo "Commit: ${{ github.sha }}"
          # Add Slack/Teams notification here if configured
      
      - name: Notify failure
        if: needs.build-and-deploy.result == 'failure'
        run: |
          echo "‚ùå Production deployment FAILED!"
          echo "Immediate investigation required."
          echo "Actor: ${{ github.actor }}"
          echo "Commit: ${{ github.sha }}"
          # Add PagerDuty/incident notification here if configured

name: Deploy to Azure Production

# Auto-deploy to production after staging succeeds
on:
  # Auto-trigger after staging deployment
  workflow_run:
    workflows: ["Deploy to Azure Staging"]
    types:
      - completed
    branches:
      - main
  
  # Also allow manual trigger with verification
  workflow_dispatch:
    inputs:
      staging_verified:
        description: 'Confirm staging has been verified'
        required: true
        default: false
      reason:
        description: 'Reason for production deployment'
        required: true
  
  # Also trigger on release
  release:
    types: [published]

env:
  ACR_NAME: ${{ secrets.PROD_ACR_NAME }}
  AZURE_WEBAPP_NAME: ${{ secrets.PROD_AZURE_WEBAPP_NAME }}
  AZURE_RESOURCE_GROUP: rg-qgp-staging
  ENVIRONMENT_NAME: production
  IMAGE_NAME: quality-governance-platform

jobs:
  # Gate: Verify staging succeeded (for auto-trigger) or manual approval
  pre-deployment-checks:
    name: Pre-Deployment Checks
    runs-on: ubuntu-latest
    # Only run if staging succeeded OR manual trigger OR release
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'release'
    outputs:
      approved: ${{ steps.check.outputs.approved }}
    
    steps:
      - name: Validate deployment request
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "‚úÖ Auto-deployment triggered by successful staging"
            echo "Staging workflow: ${{ github.event.workflow_run.html_url }}"
            echo "approved=true" >> "$GITHUB_OUTPUT"
          elif [[ "${{ github.event_name }}" == "release" ]]; then
            echo "‚úÖ Release-triggered deployment"
            echo "approved=true" >> "$GITHUB_OUTPUT"
          elif [[ "${{ github.event.inputs.staging_verified }}" == "true" ]]; then
            echo "‚úÖ Manual deployment with staging verification confirmed"
            echo "Reason: ${{ github.event.inputs.reason }}"
            echo "approved=true" >> "$GITHUB_OUTPUT"
          else
            echo "‚ùå Staging verification required!"
            echo "approved=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi

      - name: Log deployment request
        run: |
          {
            echo "## üîê Production Deployment Request"
            echo ""
            echo "| Item | Value |"
            echo "|------|-------|"
            echo "| **Trigger** | ${{ github.event_name }} |"
            echo "| **Actor** | ${{ github.actor }} |"
            echo "| **Ref** | ${{ github.ref }} |"
            echo "| **SHA** | ${{ github.sha }} |"
            if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
              echo "| **Staging Run** | [View](${{ github.event.workflow_run.html_url }}) |"
            fi
            echo "| **Reason** | ${{ github.event.inputs.reason || 'Auto-deploy after staging' }} |"
          } >> "$GITHUB_STEP_SUMMARY"

  build-and-deploy:
    name: Build and Deploy to Production
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.approved == 'true'
    environment:
      name: production
      url: https://app-qgp-prod.azurewebsites.net
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Environment guardrails
        run: |
          if [ -z "$AZURE_RESOURCE_GROUP" ] || [ -z "$AZURE_WEBAPP_NAME" ] || [ -z "$ENVIRONMENT_NAME" ]; then
            echo "‚ùå Guardrail: required env vars missing"
            exit 1
          fi
          app_lower=$(echo "$AZURE_WEBAPP_NAME" | tr '[:upper:]' '[:lower:]')
          env_lower=$(echo "$ENVIRONMENT_NAME" | tr '[:upper:]' '[:lower:]')
          # Validate app name matches environment (allows shared RG due to quota)
          if [ "$env_lower" = "production" ]; then
            if echo "$app_lower" | grep -q "staging"; then
              echo "‚ùå Guardrail: production cannot target staging app"
              exit 1
            fi
            if ! echo "$app_lower" | grep -q "prod"; then
              echo "‚ùå Guardrail: production app name must contain 'prod'"
              exit 1
            fi
          elif [ "$env_lower" = "staging" ]; then
            if echo "$app_lower" | grep -q "prod"; then
              echo "‚ùå Guardrail: staging cannot target production app"
              exit 1
            fi
          else
            echo "‚ùå Guardrail: unknown environment '$ENVIRONMENT_NAME'"
            exit 1
          fi
          echo "‚úÖ Guardrail: environment targeting validated (app: $app_lower)"

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and push Docker image
        run: |
          IMAGE_TAG="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          IMAGE_RELEASE="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:release-${{ github.run_number }}"
          
          echo "Building production image: $IMAGE_TAG"
          docker build -t "$IMAGE_TAG" -t "$IMAGE_RELEASE" .
          
          echo "Pushing images..."
          docker push "$IMAGE_TAG"
          docker push "$IMAGE_RELEASE"
          
          echo "IMAGE_TAG=$IMAGE_TAG" >> "$GITHUB_ENV"

      - name: Capture expected image digest
        run: |
          EXPECTED_TAG="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          EXPECTED_DIGESTS=$(az acr repository show-manifests \
            --name "${{ env.ACR_NAME }}" \
            --repository "${{ env.IMAGE_NAME }}" \
            --query "[?tags[?@=='${{ github.sha }}']].digest" \
            -o tsv)
          EXPECTED_DIGESTS_CLEAN=$(printf "%s\n" "$EXPECTED_DIGESTS" | sed '/^$/d' | sort -u)
          EXPECTED_DIGEST_COUNT=$(printf "%s\n" "$EXPECTED_DIGESTS_CLEAN" | wc -l | tr -d ' ')
          if [ "$EXPECTED_DIGEST_COUNT" -ne 1 ]; then
            echo "‚ùå Expected exactly 1 digest for tag ${{ github.sha }}, got $EXPECTED_DIGEST_COUNT"
            exit 1
          fi
          EXPECTED_DIGEST=$(printf "%s\n" "$EXPECTED_DIGESTS_CLEAN" | head -n 1 | tr -d '\r')
          if [ -z "$EXPECTED_DIGEST" ]; then
            echo "‚ùå Failed to resolve image digest for ${EXPECTED_TAG}"
            exit 1
          fi
          case "$EXPECTED_DIGEST" in
            sha256:*) ;;
            *)
              echo "‚ùå Unexpected digest format: $EXPECTED_DIGEST"
              exit 1
              ;;
          esac
          
          IMAGE_DIGEST_REF="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}@${EXPECTED_DIGEST}"
          EXPECTED_TAG_SAFE="${{ env.IMAGE_NAME }}:${{ github.sha }}"
          
          {
            echo "EXPECTED_TAG=$EXPECTED_TAG"
            echo "EXPECTED_DIGEST=$EXPECTED_DIGEST"
            echo "IMAGE_DIGEST_REF=$IMAGE_DIGEST_REF"
            echo "EXPECTED_TAG_SAFE=$EXPECTED_TAG_SAFE"
          } >> "$GITHUB_ENV"

      - name: Preflight validation
        run: |
          {
            echo "## ‚úÖ Preflight Validation"
            echo ""
            echo "| Item | Value |"
            echo "|------|-------|"
            echo "| **Environment** | $ENVIRONMENT_NAME |"
            echo "| **Commit** | \`${{ github.sha }}\` |"
            echo "| **Expected Digest** | \`${EXPECTED_DIGEST}\` |"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Create database backup
        run: |
          echo "Creating pre-deployment database backup..."
          # Note: Implement backup strategy based on Azure SQL/PostgreSQL setup
          # az postgres flexible-server backup create ...
          echo "Backup completed (placeholder)"

      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v3
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          images: ${{ env.IMAGE_DIGEST_REF }}

      - name: Configure App Service environment
        run: |
          echo "üîß Configuring App Service with Azure AD settings..."
          
          # Fetch secrets from Key Vault
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-prod --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name JWT-SECRET-KEY --query value -o tsv)
          
          # Configure app settings
          az webapp config appsettings set \
            --name "${{ env.AZURE_WEBAPP_NAME }}" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --settings \
              APP_ENV="production" \
              BUILD_SHA="${{ github.sha }}" \
              BUILD_TIME="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              DATABASE_URL="$DB_URL" \
              SECRET_KEY="$SECRET_KEY_VAL" \
              JWT_SECRET_KEY="$JWT_SECRET_VAL" \
              JWT_ALGORITHM="HS256" \
              JWT_ACCESS_TOKEN_EXPIRE_MINUTES="30" \
              JWT_REFRESH_TOKEN_EXPIRE_DAYS="7" \
              LOG_LEVEL="INFO" \
              DATABASE_ECHO="false" \
              WEBSITES_PORT="8000" \
              AZURE_CLIENT_ID="${{ secrets.AZURE_AD_CLIENT_ID }}" \
              AZURE_TENANT_ID="${{ secrets.AZURE_AD_TENANT_ID }}" \
            --output none
          
          echo "‚úÖ Application settings configured"

      - name: Cleanup old migration containers
        continue-on-error: true
        run: |
          echo "Cleaning up old migration containers..."
          # Delete terminated migration containers to free quota
          for container in $(az container list --resource-group "$AZURE_RESOURCE_GROUP" --query "[?starts_with(name, 'qgp-migration')].name" -o tsv); do
            STATE=$(az container show --name "$container" --resource-group "$AZURE_RESOURCE_GROUP" --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "Unknown")
            if [ "$STATE" = "Terminated" ] || [ "$STATE" = "Unknown" ]; then
              echo "Deleting container: $container (state: $STATE)"
              az container delete --name "$container" --resource-group "$AZURE_RESOURCE_GROUP" --yes || true
            fi
          done
          echo "Cleanup complete"

      - name: Run database migrations
        id: migrations
        run: |
          echo "Running migrations via Azure Container Instance..."
          
          # Fetch secrets into variables
          ACR_USERNAME=$(az acr credential show --name "${{ env.ACR_NAME }}" --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name "${{ env.ACR_NAME }}" --query "passwords[0].value" -o tsv)
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-prod --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name JWT-SECRET-KEY --query value -o tsv)
          
          # Validate secrets - FAIL if missing (no silent skip)
          if [ -z "$DB_URL" ]; then
            echo "‚ùå ERROR: Failed to retrieve DATABASE_URL from Key Vault"
            echo "migration_status=failed" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          echo "Successfully retrieved secrets from Key Vault"
          
          # Create migration container (with error handling for quota)
          if ! az container create \
            --name qgp-migration-prod-${{ github.run_number }} \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --location westeurope \
            --os-type Linux \
            --image "${{ env.IMAGE_TAG }}" \
            --registry-login-server "${{ env.ACR_NAME }}.azurecr.io" \
            --registry-username "$ACR_USERNAME" \
            --registry-password "$ACR_PASSWORD" \
            --restart-policy Never \
            --secure-environment-variables \
              DATABASE_URL="$DB_URL" \
              SECRET_KEY="$SECRET_KEY_VAL" \
              JWT_SECRET_KEY="$JWT_SECRET_VAL" \
            --command-line "alembic upgrade head" \
            --cpu 1 \
            --memory 1; then
            echo "‚ùå ERROR: Failed to create migration container (quota or provisioning failure)"
            echo "migration_status=failed" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          echo "Waiting for migration to complete..."
          
          MAX_WAIT=300
          WAITED=0
          while [ "$WAITED" -lt "$MAX_WAIT" ]; do
            STATE=$(az container show --name "qgp-migration-prod-${{ github.run_number }}" --resource-group "$AZURE_RESOURCE_GROUP" --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "Running")
            if [ "$STATE" = "Terminated" ]; then
              echo "Migration container terminated after ${WAITED}s"
              break
            fi
            echo "Migration still running... (${WAITED}s)"
            sleep 10
            WAITED=$((WAITED + 10))
          done
          
          EXIT_CODE=$(az container show --name "qgp-migration-prod-${{ github.run_number }}" --resource-group "$AZURE_RESOURCE_GROUP" --query "containers[0].instanceView.currentState.exitCode" -o tsv || echo "1")
          
          echo "Migration exit code: $EXIT_CODE"
          echo "Migration logs:"
          az container logs --name "qgp-migration-prod-${{ github.run_number }}" --resource-group "$AZURE_RESOURCE_GROUP" || true
          
          if [ "$EXIT_CODE" != "0" ]; then
            echo "‚ùå ERROR: Migration failed with exit code $EXIT_CODE"
            echo "migration_status=failed" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          echo "migration_status=success" >> "$GITHUB_OUTPUT"
          
          echo "Cleaning up migration container..."
          az container delete --name "qgp-migration-prod-${{ github.run_number }}" --resource-group "$AZURE_RESOURCE_GROUP" --yes || true

      - name: Verify migration revision
        run: |
          echo "Verifying database migration revision matches repo head..."
          
          # Get expected head revision from repo
          EXPECTED_HEAD=$(grep -r "^revision = " alembic/versions/ | grep -v down_rev | tail -1 | sed "s/.*revision = '\([^']*\)'.*/\1/")
          echo "Expected head revision: $EXPECTED_HEAD"
          
          # Create a container to check current revision
          ACR_USERNAME=$(az acr credential show --name "${{ env.ACR_NAME }}" --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name "${{ env.ACR_NAME }}" --query "passwords[0].value" -o tsv)
          DB_URL=$(az keyvault secret show --vault-name kv-qgp-prod --name DATABASE-URL --query value -o tsv)
          SECRET_KEY_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name SECRET-KEY --query value -o tsv)
          JWT_SECRET_VAL=$(az keyvault secret show --vault-name kv-qgp-prod --name JWT-SECRET-KEY --query value -o tsv)
          
          az container create \
            --name qgp-revision-check-${{ github.run_number }} \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --location westeurope \
            --os-type Linux \
            --image "${{ env.IMAGE_TAG }}" \
            --registry-login-server "${{ env.ACR_NAME }}.azurecr.io" \
            --registry-username "$ACR_USERNAME" \
            --registry-password "$ACR_PASSWORD" \
            --restart-policy Never \
            --secure-environment-variables \
              DATABASE_URL="$DB_URL" \
              SECRET_KEY="$SECRET_KEY_VAL" \
              JWT_SECRET_KEY="$JWT_SECRET_VAL" \
            --command-line "alembic current" \
            --cpu 1 \
            --memory 1
          
          # Wait for completion
          sleep 30
          MAX_WAIT=60
          WAITED=0
          while [ "$WAITED" -lt "$MAX_WAIT" ]; do
            STATE=$(az container show --name "qgp-revision-check-${{ github.run_number }}" --resource-group "$AZURE_RESOURCE_GROUP" --query "containers[0].instanceView.currentState.state" -o tsv 2>/dev/null || echo "Running")
            if [ "$STATE" = "Terminated" ]; then
              break
            fi
            sleep 5
            WAITED=$((WAITED + 5))
          done

          if [ "$STATE" != "Terminated" ]; then
            echo "‚ùå ERROR: Revision check container did not complete within ${MAX_WAIT}s"
            exit 1
          fi
          
          CURRENT_REV=$(az container logs --name "qgp-revision-check-${{ github.run_number }}" --resource-group "$AZURE_RESOURCE_GROUP" 2>/dev/null | grep -o '[a-z0-9_]*' | tail -1 || echo "unknown")
          if [ -z "$CURRENT_REV" ] || [ "$CURRENT_REV" = "unknown" ]; then
            echo "‚ùå ERROR: Unable to read revision check output"
            exit 1
          fi
          echo "Current DB revision: $CURRENT_REV"
          
          # Cleanup
          az container delete --name "qgp-revision-check-${{ github.run_number }}" --resource-group "$AZURE_RESOURCE_GROUP" --yes || true
          
          # Assert revision matches (note: alembic current may output multiple lines)
          if echo "$CURRENT_REV" | grep -q "$EXPECTED_HEAD"; then
            echo "‚úÖ Database revision matches expected head"
          else
            echo "‚ö†Ô∏è WARNING: Database revision may not match expected head"
            echo "Expected: $EXPECTED_HEAD"
            echo "Current output: $CURRENT_REV"
            echo "This may indicate migration drift - manual verification recommended"
          fi

      - name: Verify deployment - Readiness and Health checks
        run: |
          APP_URL="https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
          
          # Configuration: bounded exponential backoff
          MAX_ATTEMPTS=30
          INITIAL_INTERVAL=2
          MAX_INTERVAL=20
          TOTAL_TIMEOUT=600  # 10 minutes max
          
          echo "## üîç Readiness-First Health Verification"
          echo "Configuration: max_attempts=$MAX_ATTEMPTS, initial_interval=${INITIAL_INTERVAL}s, max_interval=${MAX_INTERVAL}s"
          echo ""
          
          START_TIME=$(date +%s)
          ATTEMPT=0
          INTERVAL=$INITIAL_INTERVAL
          READINESS_PASSED=false
          
          # Phase 1: Wait for readiness (database connected)
          echo "### Phase 1: Readiness Check (/readyz)"
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            ELAPSED=$(($(date +%s) - START_TIME))
            
            if [ $ELAPSED -ge $TOTAL_TIMEOUT ]; then
              echo "‚ùå Total timeout exceeded (${ELAPSED}s >= ${TOTAL_TIMEOUT}s)"
              break
            fi
            
            READY_RESPONSE=$(curl -s --max-time 10 "${APP_URL}/readyz" 2>/dev/null || echo '{"status":"error"}')
            READY_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${APP_URL}/readyz" 2>/dev/null || echo "000")
            
            echo "[$(date -u +%H:%M:%S)] Attempt $ATTEMPT: /readyz ‚Üí HTTP $READY_STATUS (elapsed: ${ELAPSED}s)"
            
            if [ "$READY_STATUS" = "200" ]; then
              # Check if database is connected
              if echo "$READY_RESPONSE" | grep -q '"database":"connected"'; then
                echo "‚úÖ Readiness check passed (database connected)"
                READINESS_PASSED=true
                break
              else
                echo "   ‚è≥ HTTP 200 but database not yet connected, retrying..."
              fi
            elif [ "$READY_STATUS" = "503" ] || [ "$READY_STATUS" = "502" ] || [ "$READY_STATUS" = "000" ]; then
              echo "   ‚è≥ Service warming up (HTTP $READY_STATUS), retrying in ${INTERVAL}s..."
            else
              echo "   ‚ö†Ô∏è Unexpected status $READY_STATUS, retrying in ${INTERVAL}s..."
            fi
            
            sleep $INTERVAL
            # Exponential backoff with cap
            INTERVAL=$((INTERVAL * 2))
            if [ $INTERVAL -gt $MAX_INTERVAL ]; then
              INTERVAL=$MAX_INTERVAL
            fi
          done
          
          if [ "$READINESS_PASSED" != "true" ]; then
            echo ""
            echo "‚ùå Readiness check failed after $ATTEMPT attempts"
            echo "Last response: $READY_RESPONSE"
            exit 1
          fi
          
          # Phase 2: Health check (quick, since readiness passed)
          echo ""
          echo "### Phase 2: Health Check (/healthz)"
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${APP_URL}/healthz")
          
          if [ "$HEALTH_STATUS" = "200" ]; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ùå Health check failed: HTTP $HEALTH_STATUS"
            exit 1
          fi
          
          # Phase 3: OpenAPI docs (non-blocking - timeout is acceptable)
          echo ""
          echo "### Phase 3: OpenAPI Check (/openapi.json)"
          DOCS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 15 "${APP_URL}/openapi.json" 2>/dev/null || echo "000")
          if [ "$DOCS_STATUS" = "200" ]; then
            echo "‚úÖ OpenAPI docs accessible"
          elif [ "$DOCS_STATUS" = "000" ]; then
            echo "‚ö†Ô∏è OpenAPI docs timed out - non-blocking"
          else
            echo "‚ö†Ô∏è OpenAPI docs not accessible (HTTP $DOCS_STATUS) - non-blocking"
          fi
          
          # Summary
          TOTAL_ELAPSED=$(($(date +%s) - START_TIME))
          echo ""
          echo "## ‚úÖ All health checks passed!"
          echo "Total verification time: ${TOTAL_ELAPSED}s"
          echo "Readiness attempts: $ATTEMPT"
          
          # Emit structured summary
          {
            echo "## üè• Health Verification Results"
            echo ""
            echo "| Check | Status | Details |"
            echo "|-------|--------|---------|"
            echo "| Readiness (/readyz) | ‚úÖ Passed | Database connected, $ATTEMPT attempts |"
            echo "| Health (/healthz) | ‚úÖ Passed | HTTP 200 |"
            echo "| OpenAPI (/openapi.json) | $([ "$DOCS_STATUS" = "200" ] && echo "‚úÖ Passed" || echo "‚ö†Ô∏è Warning") | HTTP $DOCS_STATUS |"
            echo "| Total Time | - | ${TOTAL_ELAPSED}s |"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Capture runtime evidence and enforce determinism
        run: |
          APP_HOST=$(az webapp show \
            --name "${{ env.AZURE_WEBAPP_NAME }}" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --query defaultHostName -o tsv)
          APP_URL="https://${APP_HOST}"
          
          echo "## üìã Runtime Evidence Collection"
          echo ""
          
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "${APP_URL}/healthz")
          echo "Health check: HTTP $HEALTH_STATUS"
          
          # Try meta/version endpoint - graceful if not yet implemented
          META_STATUS=$(curl -s -o /tmp/meta.json -w "%{http_code}" --max-time 30 "${APP_URL}/api/v1/meta/version")
          BUILD_SHA_FROM_META=""
          META_AVAILABLE=false
          
          if [ "$META_STATUS" = "200" ]; then
            echo "‚úÖ meta/version endpoint available"
            BUILD_SHA_FROM_META=$(python3 -c 'import json; print(json.load(open("/tmp/meta.json")).get("build_sha",""))' 2>/dev/null || echo "")
            META_AVAILABLE=true
          elif [ "$META_STATUS" = "404" ]; then
            echo "‚ö†Ô∏è meta/version endpoint not yet implemented (HTTP 404) - continuing with fallback verification"
          else
            echo "‚ö†Ô∏è meta/version returned HTTP $META_STATUS - continuing with fallback verification"
          fi
          
          # Get running container image info
          RUNNING_IMAGE_RAW=$(az webapp config container show \
            --name "${{ env.AZURE_WEBAPP_NAME }}" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --query "linuxFxVersion" -o tsv)
          RUNNING_IMAGE="${RUNNING_IMAGE_RAW#DOCKER|}"
          RUNNING_IMAGE_SAFE="${RUNNING_IMAGE#*/}"
          echo "Running image: ${RUNNING_IMAGE_SAFE}"
          
          # Verify deployed image matches expected
          IMAGE_VERIFIED=false
          if [ -z "$RUNNING_IMAGE" ]; then
            echo "‚ö†Ô∏è Running image not reported; skipping digest/tag comparison"
          elif echo "$RUNNING_IMAGE" | grep -q "@sha256:"; then
            RUNNING_DIGEST="${RUNNING_IMAGE##*@}"
            if [ "$RUNNING_DIGEST" = "$EXPECTED_DIGEST" ]; then
              echo "‚úÖ Image digest verified: ${RUNNING_DIGEST}"
              IMAGE_VERIFIED=true
            else
              echo "‚ùå Running digest mismatch: expected ${EXPECTED_DIGEST}, got ${RUNNING_DIGEST}"
              exit 1
            fi
          elif echo "$RUNNING_IMAGE" | grep -q ":"; then
            RUNNING_TAG=$(echo "$RUNNING_IMAGE_SAFE" | awk -F: '{print $NF}')
            if [ "$RUNNING_TAG" = "${{ github.sha }}" ]; then
              echo "‚úÖ Image tag verified: ${RUNNING_TAG}"
              IMAGE_VERIFIED=true
            else
              echo "‚ùå Running tag mismatch: expected ${{ github.sha }}, got ${RUNNING_TAG}"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è Running image format unrecognized; skipping digest/tag comparison"
          fi
          
          # Verify build_sha from meta/version if available
          if [ "$META_AVAILABLE" = "true" ] && [ -n "$BUILD_SHA_FROM_META" ]; then
            if [ "$BUILD_SHA_FROM_META" != "${{ github.sha }}" ]; then
              echo "‚ùå build_sha mismatch: expected ${{ github.sha }}, got ${BUILD_SHA_FROM_META}"
              exit 1
            fi
            echo "‚úÖ build_sha verified via meta/version: ${BUILD_SHA_FROM_META}"
          elif [ "$IMAGE_VERIFIED" = "true" ]; then
            echo "‚úÖ Deployment verified via image tag/digest (meta/version not available)"
          else
            echo "‚ö†Ô∏è Neither meta/version nor image verification available - proceeding with caution"
          fi
          
          # Generate evidence file
          EVIDENCE_PATH="docs/evidence/DEPLOY_EVIDENCE_production_${{ github.run_id }}.md"
          HOST_HASH=$(APP_HOST="$APP_HOST" python3 -c 'import hashlib, os; host=os.environ.get("APP_HOST",""); print(hashlib.sha256(host.encode("utf-8")).hexdigest() if host else "")')
          
          mkdir -p docs/evidence
          {
            echo "## Deploy Evidence (production)"
            echo ""
            echo "- run_id: ${{ github.run_id }}"
            echo "- sha: ${{ github.sha }}"
            echo "- expected_tag: ${EXPECTED_TAG_SAFE}"
            echo "- expected_digest: ${EXPECTED_DIGEST}"
            echo "- running_image: ${RUNNING_IMAGE_SAFE}"
            echo "- meta_version_status: HTTP ${META_STATUS}"
            echo "- meta_version_build_sha: ${BUILD_SHA_FROM_META:-N/A}"
            echo "- healthz_status: HTTP ${HEALTH_STATUS}"
            echo "- image_verified: ${IMAGE_VERIFIED}"
            echo "- host_sha256: ${HOST_HASH}"
            echo "- timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          } > "$EVIDENCE_PATH"
          
          echo ""
          echo "‚úÖ Evidence captured to ${EVIDENCE_PATH}"

      - name: Upload deploy evidence artifact
        uses: actions/upload-artifact@v4
        with:
          name: deploy-evidence-production-${{ github.run_id }}
          path: docs/evidence/DEPLOY_EVIDENCE_production_${{ github.run_id }}.md

      - name: Verify deployment - Security checks (Stage 4)
        run: |
          echo "Running post-deployment security verification..."
          PROD_URL="https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
          
          # Test 1: Auth required for incidents (no email filter)
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL/api/v1/incidents/")
          if [ "$STATUS" != "401" ]; then
            echo "‚ùå SECURITY ISSUE: Incidents accessible without auth (got $STATUS, expected 401)"
            exit 1
          fi
          echo "‚úÖ Auth required for incidents"
          
          # Test 2: Auth required for incidents WITH email filter (CVE fix verification)
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL/api/v1/incidents/?reporter_email=test@example.com")
          if [ "$STATUS" != "401" ]; then
            echo "‚ùå CRITICAL SECURITY ISSUE: Email filter bypass detected (got $STATUS, expected 401)"
            exit 1
          fi
          echo "‚úÖ CVE fix verified: Auth required for incidents with email filter"
          
          # Test 3: Auth required for complaints WITH email filter
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL/api/v1/complaints/?complainant_email=test@example.com")
          if [ "$STATUS" != "401" ]; then
            echo "‚ùå CRITICAL SECURITY ISSUE: Email filter bypass detected (got $STATUS, expected 401)"
            exit 1
          fi
          echo "‚úÖ CVE fix verified: Auth required for complaints with email filter"
          
          # Test 4: Auth required for RTAs WITH email filter
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL/api/v1/rtas/?reporter_email=test@example.com")
          if [ "$STATUS" != "401" ]; then
            echo "‚ùå CRITICAL SECURITY ISSUE: Email filter bypass detected (got $STATUS, expected 401)"
            exit 1
          fi
          echo "‚úÖ CVE fix verified: Auth required for RTAs with email filter"
          
          # Test 5: Security headers present
          HEADERS=$(curl -sI "$PROD_URL/healthz")
          if ! echo "$HEADERS" | grep -qi "x-content-type-options"; then
            echo "‚ö†Ô∏è Warning: X-Content-Type-Options header missing"
          else
            echo "‚úÖ Security headers present"
          fi
          
          # Test 6: Rate limit headers present
          HEADERS=$(curl -sI "$PROD_URL/api/v1/incidents/")
          if echo "$HEADERS" | grep -qi "x-ratelimit"; then
            echo "‚úÖ Rate limiting active"
          else
            echo "‚ö†Ô∏è Warning: Rate limit headers not found (may be configured differently)"
          fi
          
          echo ""
          echo "‚úÖ All security verification checks passed!"

      - name: Production deployment summary
        run: |
          {
            echo "## üöÄ Production Deployment Summary"
            echo ""
            echo "| Item | Value |"
            echo "|------|-------|"
            echo "| **Commit** | ${{ github.sha }} |"
            echo "| **Image** | ${{ env.IMAGE_NAME }}:${{ github.sha }} |"
            echo "| **Deployed By** | ${{ github.actor }} |"
            echo "| **Trigger** | ${{ github.event_name }} |"
            echo "| **Status** | ‚úÖ Deployed |"
          } >> "$GITHUB_STEP_SUMMARY"

  # Notify on completion
  notify:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: always()
    
    steps:
      - name: Notify success
        if: needs.build-and-deploy.result == 'success'
        run: |
          echo "üéâ Production deployment successful!"
          echo "Deployed by: ${{ github.actor }}"
          echo "Trigger: ${{ github.event_name }}"
          echo "Commit: ${{ github.sha }}"
          # Add Slack/Teams notification here if configured
      
      - name: Notify failure
        if: needs.build-and-deploy.result == 'failure'
        run: |
          echo "‚ùå Production deployment FAILED!"
          echo "Immediate investigation required."
          echo "Actor: ${{ github.actor }}"
          echo "Commit: ${{ github.sha }}"
          # Add PagerDuty/incident notification here if configured
